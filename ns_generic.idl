///////////////////////////////////////////////////////////////////////////////
// Name:        nsall.idl
// Purpose:     wxwebconnect: embedded web browser control library
// Author:      Benjamin I. Williams, Peter Fritz
// Modified by:
// Created:     2006-10-08
// RCS-ID:      
// Copyright:   (C) Copyright 2006-2010, Kirix Corporation, All Rights Reserved.
// Licence:     wxWindows Library Licence, Version 3.1
///////////////////////////////////////////////////////////////////////////////


// To generate an .h file from this .idl file, run the following command
//    xpidl -m header nsall.idl


///////////////////////////////////////////////////////////////////////////////
//  nsrootidl
///////////////////////////////////////////////////////////////////////////////


%{C++
#if 0
%}

typedef unsigned long nsresult;
typedef unsigned long nsrefcnt;
typedef unsigned long PRUint32;
typedef long PRInt32;
typedef long long PRInt64;
typedef unsigned long long PRTime;
typedef PRInt32 PRBool;

[ref, nsid]   native nsIIDRef(nsIID);
[ref, nsid]   native nsCIDRef(nsCID);


[ref, utf8string] native AUTF8String(ignored);

[ref, astring] native AString(ignored);
[ref, cstring] native ACString(ignored);
[ref, domstring] native DOMString(ignored);

[nsid] native nsIID(nsIID);
[ref, nsid]   native nsIDRef(nsID);
//[ref, nsid] native nsIIDRef(nsIID);
[ptr, nsid]   native nsIDPtr(nsID);
[ptr, nsid]   native nsIIDPtr(nsIID);
[ptr] native nsQIResult(void);
[nsid] native nsCID(nsCID);
//[ref, nsid] native nsCIDRef(nsCID);
[ptr, nsid] native nsCIDPtr(nsCID);

[ptr] native voidPtr(void);
[ref] native voidPtrRef(void*);
[ptr] native charPtr(char);
[ref] native PRBoolRef(PRBool);


%{C++
#endif
%}




///////////////////////////////////////////////////////////////////////////////
//  nsISupports
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(00000000-0000-0000-c000-000000000046)]
interface nsISupports
{
    void QueryInterface(in nsIIDRef iid,
                        [iid_is(iid), retval] out nsQIResult result);
    [noscript, notxpcom] nsrefcnt AddRef();
    [noscript, notxpcom] nsrefcnt Release();
};




///////////////////////////////////////////////////////////////////////////////
//  nsISimpleEnumerator
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(d1899240-f9d2-11d2-bdd6-000064657374)]
interface nsISimpleEnumerator : nsISupports
{
    boolean hasMoreElements();
    nsISupports getNext();
};




///////////////////////////////////////////////////////////////////////////////
//  nsIFactory
///////////////////////////////////////////////////////////////////////////////


[scriptable, object, uuid(00000001-0000-0000-c000-000000000046)]
interface nsIFactory : nsISupports
{
    void createInstance(in nsISupports outer,
                        in nsIIDRef iid,
                        [iid_is(iid),retval] out nsQIResult result);
                        
    void lockFactory(in boolean lock);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIInterfaceRequestor
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(033a1470-8b2a-11d3-af88-00a024ffc08c)]
interface nsIInterfaceRequestor : nsISupports
{
    void getInterface(in nsIIDRef iid,
                      [iid_is(iid), retval] out nsQIResult result);
                      
/*
    This error is already present on http://developer.mozilla.org/xpcom/api/.
    On http://www.xulplanet.com the function reads:
    void getInterface (nsIIDRef uuid, out nsQIResult* result)
*/
};




///////////////////////////////////////////////////////////////////////////////
//  nsIWeakReference
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(9188bc85-f92e-11d2-81ef-0060083a0bcf)]
interface nsIWeakReference : nsISupports
{
    void QueryReferent(in nsIIDRef iid,
                       [iid_is(iid), retval] out nsQIResult result);
};

[scriptable, uuid(9188bc86-f92e-11d2-81ef-0060083a0bcf)]
interface nsISupportsWeakReference : nsISupports
{
    nsIWeakReference GetWeakReference();
};




///////////////////////////////////////////////////////////////////////////////
//  nsIFile
///////////////////////////////////////////////////////////////////////////////


interface nsISimpleEnumerator;

[scriptable, uuid(c8c0a080-0868-11d3-915f-d9d889d48e3c)]
interface nsIFile : nsISupports
{
    const unsigned long NORMAL_FILE_TYPE = 0;
    const unsigned long DIRECTORY_TYPE   = 1;
    
    void append(in AString node);
    [noscript] void appendNative(in ACString node);
    void normalize();
    void create(in PRUint32 type, in PRUint32 permissions);

    attribute AString leafName;
    [noscript] attribute ACString nativeLeafName;

    void copyTo(in nsIFile parent_dir, in AString name);
    [noscript] void copyToNative(in nsIFile parent_dir, in ACString name);
    void copyToFollowingLinks(in nsIFile parent_dir, in AString name);
    [noscript] void copyToFollowingLinksNative(in nsIFile parent_dir,
                                               in ACString name);
    void moveTo(in nsIFile parent_dir, in AString name);
    [noscript] void moveToNative(in nsIFile parent_dir, in ACString name);
    void remove(in boolean recursive);
    
    attribute unsigned long permissions;
    attribute unsigned long permissionsOfLink;
    attribute PRInt64 lastModifiedTime;
    attribute PRInt64 lastModifiedTimeOfLink;
    attribute PRInt64 fileSize;
    readonly attribute PRInt64 fileSizeOfLink;
    
    readonly attribute AString target;
    [noscript] readonly attribute ACString nativeTarget;
    
    readonly attribute AString path;
    [noscript] readonly attribute ACString nativePath;
    
    boolean exists();
    boolean isWritable();
    boolean isReadable();
    boolean isExecutable();
    boolean isHidden();
    boolean isDirectory();
    boolean isFile();
    boolean isSymlink();
    boolean isSpecial();
    void createUnique(in PRUint32 type, in PRUint32 permissions);
    nsIFile clone();
    boolean equals(in nsIFile file);
    boolean contains(in nsIFile file, in boolean recurse);
    
    readonly attribute nsIFile parent;
    readonly attribute nsISimpleEnumerator directoryEntries;
};




///////////////////////////////////////////////////////////////////////////////
//  nsILocalFile
///////////////////////////////////////////////////////////////////////////////


%{C++
struct PRFileDesc;
struct PRLibrary;
%}

[ptr] native PRFileDescStar(PRFileDesc);
[ptr] native PRLibraryStar(PRLibrary);
[ptr] native FILEStar(FILE);


[scriptable, uuid(aa610f20-a889-11d3-8c81-000064657374)]
interface nsILocalFile : nsIFile
{
    void initWithPath(in AString file_path);
    [noscript] void initWithNativePath(in ACString file_path);
    void initWithFile(in nsILocalFile file);
    
    attribute boolean followLinks;

    [noscript] PRFileDescStar openNSPRFileDesc(in long flags, in long mode);
    [noscript] FILEStar openANSIFileDesc(in string mode);
    [noscript] PRLibraryStar load();
    void appendRelativePath(in AString rel_path);
    [noscript] void appendRelativeNativePath(in ACString rel_path);
    
    attribute ACString persistentDescriptor;
    
    void reveal();
    void launch();
    
    ACString getRelativeDescriptor(in nsILocalFile from_file);
    void setRelativeDescriptor(in nsILocalFile from_file, in ACString rel_desc);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIBadCertListener
///////////////////////////////////////////////////////////////////////////////


interface nsIInterfaceRequestor;
interface nsIInterfaceRequestor;


[scriptable, uuid(f0980f60-ee3d-11d4-998b-00b0d02354a0)]
interface nsIX509Cert : nsISupports
{
    // to be filled out later
};


[scriptable, uuid(cfede939-def1-49be-81ed-d401b3a07d1c)]
interface nsISSLStatus : nsISupports
{
    readonly attribute nsIX509Cert serverCert;
    readonly attribute string cipherName;
    readonly attribute unsigned long keyLength;
    readonly attribute unsigned long secretKeyLength;
    readonly attribute boolean isDomainMismatch;
    readonly attribute boolean isNotValidAtThisTime;
    readonly attribute boolean isUntrusted;
};



[scriptable, uuid(2c3d268c-ad82-49f3-99aa-e9ffddd7a0dc)]
interface nsIBadCertListener2 : nsISupports
{
    boolean notifyCertProblem(in nsIInterfaceRequestor socket_info, 
                              in nsISSLStatus status,
                              in AUTF8String target_site);
};


[scriptable, uuid(a5ae8b05-a76e-408f-b0ba-02a831265749)]
interface nsIRecentBadCertsService : nsISupports
{
    nsISSLStatus getRecentBadCert(in AString host_name_with_port);
    
    void addBadCert(in AString host_name_with_port,
                    in nsISSLStatus status);
};



[scriptable, uuid(31738d2a-77d3-4359-84c9-4be2f38fb8c5)]
interface nsICertOverrideService : nsISupports
{
    const short ERROR_UNTRUSTED = 1;
    const short ERROR_MISMATCH = 2;
    const short ERROR_TIME = 4;

    void rememberValidityOverride(
                            in ACString host_name, 
                            in PRInt32 port,
                            in nsIX509Cert cert,
                            in PRUint32 override_bits,
                            in boolean temporary);

    boolean hasMatchingOverride(
                            in ACString host_name, 
                            in PRInt32 port,
                            in nsIX509Cert cert,
                            out PRUint32 override_bits,
                            out boolean is_temporary);

    boolean getValidityOverride(
                            in ACString host_name, 
                            in PRInt32 port,
                            out ACString hash_alg,
                            out ACString fingerprint,
                            out PRUint32 override_bits,
                            out boolean is_temporary);

    void clearValidityOverride(
                            in ACString host_name,
                            in PRInt32 port);

    void getAllOverrideHostsWithPorts(
                            out PRUint32 count, 
                            [array, size_is(count)] out wstring hosts_with_ports_array);

    PRUint32 isCertUsedForOverrides(
                            in nsIX509Cert cert,
                            in boolean check_temporaries,
                            in boolean check_permanents);
};



///////////////////////////////////////////////////////////////////////////////
//  nsIBaseWindow
///////////////////////////////////////////////////////////////////////////////


typedef voidPtr nativeWindow;
[ptr] native nsIWidget(nsIWidget);

%{ C++
    class nsIWidget;
%}

[scriptable, uuid(046bc8a0-8015-11d3-af70-00a024ffc08c)]
interface nsIBaseWindow : nsISupports
{
    [noscript] void initWindow(in nativeWindow parentNativeWindow,
                               in nsIWidget parentWidget,
                               in long x,
                               in long y,
                               in long cx,
                               in long cy);
    void create();
    void destroy();
    
    void setPosition(in long x, in long y);
    void getPosition(out long x, out long y);
    
    void setSize(in long cx, in long cy, in boolean repaint);
    void getSize(out long cx, out long cy);

    void setPositionAndSize(in long x,
                            in long y,
                            in long cx,
                            in long cy,
                            in boolean repaint);

    void getPositionAndSize(out long x,
                            out long y,
                            out long cx,
                            out long cy);

    void repaint(in boolean force);

    [noscript] attribute nsIWidget parentWidget;
    attribute nativeWindow parentNativeWindow;
    attribute boolean visibility;
    attribute boolean enabled;
    attribute boolean blurSuppression;
    [noscript] readonly attribute nsIWidget mainWidget;

    void setFocus();

    attribute wstring title;
};






///////////////////////////////////////////////////////////////////////////////
//  nsICancelable
///////////////////////////////////////////////////////////////////////////////


[scriptable, object, uuid(d94ac0a0-bb18-46b8-844e-84159064b0bd)]
interface nsICancelable : nsISupports
{
    void cancel(in nsresult reason);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIRequest
///////////////////////////////////////////////////////////////////////////////


interface nsILoadGroup;
typedef unsigned long nsLoadFlags;


[scriptable, uuid(ef6bfbd2-fd46-48d8-96b7-9f8f0fd387fe)]
interface nsIRequest : nsISupports
{
    const unsigned long LOAD_NORMAL = 0;
    const unsigned long LOAD_BACKGROUND = 1;
    const unsigned long INHIBIT_CACHING = 128;
    const unsigned long INHIBIT_PERSISTENT_CACHING = 256;
    const unsigned long LOAD_BYPASS_CACHE = 512;
    const unsigned long LOAD_FROM_CACHE = 1024;
    const unsigned long VALIDATE_ALWAYS = 2048;
    const unsigned long VALIDATE_NEVER = 4096;
    const unsigned long VALIDATE_ONCE_PER_SESSION = 8192;

    readonly attribute AUTF8String name;
    
    boolean isPending();
    
    readonly attribute nsresult status;
    
    void cancel(in nsresult status);
    void suspend();
    void resume();
    
    attribute nsILoadGroup loadGroup;
    attribute nsLoadFlags loadFlags;
};




///////////////////////////////////////////////////////////////////////////////
//  nsIURI
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(07a22cc0-0ce5-11d3-9331-00104ba0fd40)]
interface nsIURI : nsISupports
{
    attribute AUTF8String spec;
    readonly attribute AUTF8String prePath;
    attribute ACString scheme;
    attribute AUTF8String userPass;
    attribute AUTF8String username;
    attribute AUTF8String password;
    attribute AUTF8String hostPort;
    attribute AUTF8String host;
    attribute long port;
    attribute AUTF8String path;

    boolean equals(in nsIURI other);
    boolean schemeIs(in string scheme);
    nsIURI clone();
    AUTF8String resolve(in AUTF8String relative_path);
    
    readonly attribute ACString asciiSpec;
    readonly attribute ACString asciiHost;
    readonly attribute ACString originCharset;
};


///////////////////////////////////////////////////////////////////////////////
//  nsIURIFixup
///////////////////////////////////////////////////////////////////////////////

[scriptable, uuid(773081ac-9f81-4bdb-9e7a-5e87b4361f09)]
interface nsIURIFixup : nsISupports
{
    const unsigned long FIXUP_FLAG_NONE = 0;
    const unsigned long FIXUP_FLAG_ALLOW_KEYWORD_LOOKUP = 1;
    const unsigned long FIXUP_FLAGS_MAKE_ALTERNATE_URI = 2;

    nsIURI createExposableURI(in nsIURI uri);
    nsIURI createFixupURI(in AUTF8String aURIText, in unsigned long fixup_flags);
    nsIURI keywordToURI(in AUTF8String keyword);
};



///////////////////////////////////////////////////////////////////////////////
//  nsIChannel
///////////////////////////////////////////////////////////////////////////////

interface nsIInterfaceRequestor;
interface nsIInputStream;
interface nsIStreamListener;

[scriptable, uuid(c63a055a-a676-4e71-bf3c-6cfa11082018)]
interface nsIChannel : nsIRequest
{
    const unsigned long LOAD_DOCUMENT_URI = 65536;
    const unsigned long LOAD_RETARGETED_DOCUMENT_URI = 131072;
    const unsigned long LOAD_REPLACE = 262144;
    const unsigned long LOAD_INITIAL_DOCUMENT_URI = 524288;
    const unsigned long LOAD_TARGETED = 1048576;

    attribute nsIURI originalURI;
    readonly attribute nsIURI URI;
    attribute nsISupports owner;
    attribute nsIInterfaceRequestor notificationCallbacks;
    readonly attribute nsISupports securityInfo;
    attribute ACString contentType;
    attribute ACString contentCharset;
    attribute long contentLength;


    nsIInputStream open();
    void asyncOpen(in nsIStreamListener listener, in nsISupports xcontext);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIClipboardCommands
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(b8100c90-73be-11d2-92a5-00105a1b0d64)]
interface nsIClipboardCommands : nsISupports
{
    boolean canCutSelection();
    boolean canCopySelection();
    boolean canCopyLinkLocation();
    boolean canCopyImageLocation();
    boolean canCopyImageContents();
    boolean canPaste();
    void cutSelection();
    void copySelection();
    void copyLinkLocation();
    void copyImageLocation();
    void copyImageContents();
    void paste();
    void selectAll();
    void selectNone();
};




///////////////////////////////////////////////////////////////////////////////
//  nsIComponentManager
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(a88e5a60-205a-4bb1-94e1-2628daf51eae)]
interface nsIComponentManager : nsISupports
{
    void getClassObject(in nsCIDRef class_id,
                        in nsIIDRef iid,
                        [iid_is(iid),retval] out nsQIResult result);
                        
    void getClassObjectByContractID(
                        in string contract_id,
                        in nsIIDRef iid,
                        [iid_is(iid),retval] out nsQIResult result);
                                  
    void createInstance(in nsCIDRef class_id,
                        in nsISupports delegate,
                        in nsIIDRef iid,
                        [iid_is(iid),retval] out nsQIResult result);
                        
    void createInstanceByContractID(
                        in string contract_id,
                        in nsISupports delegate,
                        in nsIIDRef iid,
                        [iid_is(iid),retval] out nsQIResult result);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIComponentRegistrar
///////////////////////////////////////////////////////////////////////////////


interface nsIFactory;
interface nsISimpleEnumerator;

[scriptable, uuid(2417cbfe-65ad-48a6-b4b6-eb84db174392)]
interface nsIComponentRegistrar : nsISupports
{
    void autoRegister(in nsIFile spec);
    void autoUnregister(in nsIFile spec);
    
    void registerFactory(in nsCIDRef class_id,
                         in string class_name,
                         in string contract_id,
                         in nsIFactory factory);
                         
    void unregisterFactory(
                         in nsCIDRef class_id,
                         in nsIFactory factory);
                         
    void registerFactoryLocation(
                         in nsCIDRef class_id,
                         in string class_name,
                         in string contract_id,
                         in nsIFile file,
                         in string loader_str,
                         in string type);
                         
    void unregisterFactoryLocation(
                         in nsCIDRef class_id,
                         in nsIFile file);
                         
    boolean isCIDRegistered(in nsCIDRef class_id);
    boolean isContractIDRegistered(in string contract_id);
    nsISimpleEnumerator enumerateCIDs();
    nsISimpleEnumerator enumerateContractIDs();
    string CIDToContractID(in nsCIDRef class_id);
    nsCIDPtr contractIDToCID(in string contract_id);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIContextMenuListener2
///////////////////////////////////////////////////////////////////////////////


interface nsIContextMenuInfo;
interface nsIDOMEvent;
interface nsIDOMNode;
interface imgIContainer;


[scriptable, uuid(7fb719b3-d804-4964-9596-77cf924ee314)]
interface nsIContextMenuListener2 : nsISupports
{
    void onShowContextMenu(in unsigned long context_flags,
                           in nsIContextMenuInfo utils);
};


 
[scriptable, uuid(2f977d56-5485-11d4-87e2-0010a4e75ef2)]
interface nsIContextMenuInfo : nsISupports
{
    readonly attribute nsIDOMEvent mouseEvent;
    readonly attribute nsIDOMNode targetNode;
    readonly attribute AString associatedLink;
    readonly attribute imgIContainer imageContainer;
    readonly attribute nsIURI imageSrc;
    readonly attribute imgIContainer backgroundImageContainer;
    readonly attribute nsIURI backgroundImageSrc;
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDirectoryService
///////////////////////////////////////////////////////////////////////////////


interface nsISimpleEnumerator;


[scriptable, uuid(bbf8cab0-d43a-11d3-8cc2-00609792278c)]
interface nsIDirectoryServiceProvider : nsISupports
{
    nsIFile getFile(in string property, out boolean persistent);
};


[scriptable, uuid(2f977d4b-5485-11d4-87e2-0010a4e75ef2)]
interface nsIDirectoryServiceProvider2 : nsIDirectoryServiceProvider
{
    nsISimpleEnumerator getFiles(in string property);
};


[scriptable, uuid(57a66a60-d43a-11d3-8cc2-00609792278c)]
interface nsIDirectoryService : nsISupports
{
    void init();
    void registerProvider(in nsIDirectoryServiceProvider provider);
    void unregisterProvider(in nsIDirectoryServiceProvider provider);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDocShellTreeItem
///////////////////////////////////////////////////////////////////////////////


interface nsIDocShellTreeOwner;
interface nsIDocShellTreeItem;


[scriptable, uuid(37f1ab73-f224-44b1-82f0-d2834ab1cec0)]
interface nsIDocShellTreeNode : nsISupports
{
    readonly attribute long childCount;
    void addChild(in nsIDocShellTreeItem child);
    void removeChild(in nsIDocShellTreeItem child);
    nsIDocShellTreeItem getChildAt(in long index);
    nsIDocShellTreeItem findChildWithName(in wstring name,
                                          in boolean recurse,
                                          in boolean same_type,
                                          in nsIDocShellTreeItem requestor,
                                          in nsIDocShellTreeItem original_requestor);
};


[scriptable, uuid(09b54ec1-d98a-49a9-bc95-3219e8b55089)]
interface nsIDocShellTreeItem : nsIDocShellTreeNode
{
    attribute wstring name;

    boolean nameEquals(in wstring name);

    const long typeChrome = 0;
    const long typeContent = 1;
    const long typeContentWrapper = 2;
    const long typeChromeWrapper = 3;
    const long typeAll = 2147483647;

    attribute long itemType;

    readonly attribute nsIDocShellTreeItem parent;
    readonly attribute nsIDocShellTreeItem sameTypeParent;
    readonly attribute nsIDocShellTreeItem rootTreeItem;
    readonly attribute nsIDocShellTreeItem sameTypeRootTreeItem;

    nsIDocShellTreeItem findItemWithName(in wstring name,
                                         in nsISupports requestor,
                                         in nsIDocShellTreeItem original_requestor);
                                         
    readonly attribute nsIDocShellTreeOwner treeOwner;

    [noscript] void setTreeOwner(in nsIDocShellTreeOwner tree_owner);
};



///////////////////////////////////////////////////////////////////////////////
//  nsIDOMNode
///////////////////////////////////////////////////////////////////////////////


interface nsIDOMNodeList;
interface nsIDOMNamedNodeMap;
interface nsIDOMDocument;
interface DOMException;

[scriptable, uuid(a6cf907c-15b3-11d2-932e-00805f8add32)]
interface nsIDOMNode : nsISupports
{
    const unsigned short ELEMENT_NODE = 1;
    const unsigned short ATTRIBUTE_NODE = 2;
    const unsigned short TEXT_NODE = 3;
    const unsigned short CDATA_SECTION_NODE = 4;
    const unsigned short ENTITY_REFERENCE_NODE = 5;
    const unsigned short ENTITY_NODE = 6;
    const unsigned short PROCESSING_INSTRUCTION_NODE = 7;
    const unsigned short COMMENT_NODE = 8;
    const unsigned short DOCUMENT_NODE = 9;
    const unsigned short DOCUMENT_TYPE_NODE = 10;
    const unsigned short DOCUMENT_FRAGMENT_NODE = 11;
    const unsigned short NOTATION_NODE = 12;

    readonly attribute DOMString nodeName;
    attribute DOMString nodeValue;
    readonly attribute unsigned short nodeType;
    readonly attribute nsIDOMNode parentNode;
    readonly attribute nsIDOMNodeList childNodes;
    readonly attribute nsIDOMNode firstChild;
    readonly attribute nsIDOMNode lastChild;
    readonly attribute nsIDOMNode previousSibling;
    readonly attribute nsIDOMNode nextSibling;
    readonly attribute nsIDOMNamedNodeMap attributes;
    readonly attribute nsIDOMDocument ownerDocument;
           
    nsIDOMNode insertBefore(in nsIDOMNode new_child, in nsIDOMNode ref_child) raises(DOMException);
    nsIDOMNode replaceChild(in nsIDOMNode new_child, in nsIDOMNode old_child) raises(DOMException);
    nsIDOMNode removeChild(in nsIDOMNode old_child)  raises(DOMException);
    nsIDOMNode appendChild(in nsIDOMNode new_child) raises(DOMException);
    boolean hasChildNodes();
    nsIDOMNode cloneNode(in boolean deep);
    void normalize();
    boolean isSupported(in DOMString feature, in DOMString version);
    
    readonly attribute DOMString namespaceURI;
    attribute DOMString prefix;
    readonly attribute DOMString localName;
    
    boolean hasAttributes();
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDOM3Node
///////////////////////////////////////////////////////////////////////////////


interface nsIDOMNode;
interface DOMException;
interface nsIVariant;
interface nsIDOMUserDataHandler;

[scriptable, uuid(29fb2a18-1dd2-11b2-8dd9-a6fd5d5ad12f)]
interface nsIDOM3Node : nsISupports
{
    const unsigned short DOCUMENT_POSITION_DISCONNECTED = 0x01;
    const unsigned short DOCUMENT_POSITION_PRECEDING = 0x02;
    const unsigned short DOCUMENT_POSITION_FOLLOWING = 0x04;
    const unsigned short DOCUMENT_POSITION_CONTAINS = 0x08;
    const unsigned short DOCUMENT_POSITION_CONTAINED_BY = 0x10;
    const unsigned short DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 0x20;
    
    readonly attribute DOMString       baseURI;

    unsigned short compareDocumentPosition(in nsIDOMNode other) raises(DOMException);

    attribute DOMString       textContent;

    boolean isSameNode(in nsIDOMNode other);
    DOMString lookupPrefix(in DOMString namespaceURI);
    boolean isDefaultNamespace(in DOMString namespaceURI);
    DOMString lookupNamespaceURI(in DOMString prefix);
    boolean isEqualNode(in nsIDOMNode arg);
    nsISupports getFeature(in DOMString feature, in DOMString version);
    nsIVariant setUserData(in DOMString key, in nsIVariant data, in nsIDOMUserDataHandler handler);
    nsIVariant getUserData(in DOMString key);
};






///////////////////////////////////////////////////////////////////////////////
//  nsIDOMAttr
///////////////////////////////////////////////////////////////////////////////


interface nsIDOMElement;

[scriptable, uuid(a6cf9070-15b3-11d2-932e-00805f8add32)]
interface nsIDOMAttr : nsIDOMNode
{
    readonly attribute DOMString name;
    readonly attribute boolean specified;
    attribute DOMString value;
    readonly attribute nsIDOMElement ownerElement;
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDOMElement
///////////////////////////////////////////////////////////////////////////////


interface nsIDOMAttr;
interface DOMException;


[scriptable, uuid(a6cf9078-15b3-11d2-932e-00805f8add32)]
interface nsIDOMElement : nsIDOMNode
{
    readonly attribute DOMString tagName;

    DOMString getAttribute(in DOMString name);

    void setAttribute(in DOMString name,
                      in DOMString value) raises(DOMException);

    void removeAttribute(in DOMString name) raises(DOMException);

    nsIDOMAttr getAttributeNode(in DOMString name);
    nsIDOMAttr setAttributeNode(in nsIDOMAttr new_attr) raises(DOMException);

    nsIDOMAttr removeAttributeNode(in nsIDOMAttr old_attr) raises(DOMException);
 
    nsIDOMNodeList getElementsByTagName(in DOMString name);

    DOMString getAttributeNS(in DOMString namespace_uri,
                             in DOMString local_name);

    void setAttributeNS(in DOMString namespace_uri,
                        in DOMString qualified_name,
                        in DOMString value) raises(DOMException);
      
    void removeAttributeNS(in DOMString namespace_uri,
                           in DOMString local_name) raises(DOMException);

    nsIDOMAttr getAttributeNodeNS(in DOMString namespace_uri,
                                  in DOMString local_name);
         
    nsIDOMAttr setAttributeNodeNS(in nsIDOMAttr newAttr) raises(DOMException);
    
    nsIDOMNodeList getElementsByTagNameNS(in DOMString namespace_uri,
                                          in DOMString local_name);
               
    boolean hasAttribute(in DOMString name);

    boolean hasAttributeNS(in DOMString namespace_uri,
                           in DOMString local_name);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDOMCharacterData
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(a6cf9072-15b3-11d2-932e-00805f8add32)]
interface nsIDOMCharacterData : nsIDOMNode
{
    attribute DOMString data;
    readonly attribute unsigned long length;
    
    DOMString substringData(in unsigned long offset,
                            in unsigned long count)
                            raises(DOMException);
                            
    void appendData(in DOMString arg)
                    raises(DOMException);
                    
    void insertData(in unsigned long offset,
                    in DOMString arg)
                    raises(DOMException);
                    
    void deleteData(in unsigned long offset,
                    in unsigned long count)
                    raises(DOMException);
                    
    void replaceData(in unsigned long offset,
                     in unsigned long count,
                     in DOMString arg)
                     raises(DOMException);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDOMDocument
///////////////////////////////////////////////////////////////////////////////


interface nsIDOMText;
interface nsIDOMDocumentType;
interface nsIDOMDOMImplementation;
interface nsIDOMElement;
interface nsIDOMDocumentFragment;
interface nsIDOMComment;
interface nsIDOMCDATASection;
interface nsIDOMProcessingInstruction;
interface nsIDOMAttr;
interface nsIDOMEntityReference;


[scriptable, uuid(a6cf9075-15b3-11d2-932e-00805f8add32)]
interface nsIDOMDocument : nsIDOMNode
{
    readonly attribute nsIDOMDocumentType doctype;
    readonly attribute nsIDOMDOMImplementation implementation;
    readonly attribute nsIDOMElement documentElement;
  
    nsIDOMElement createElement(in DOMString tagName) raises(DOMException);
    nsIDOMDocumentFragment createDocumentFragment();
    nsIDOMText createTextNode(in DOMString data);
    nsIDOMComment createComment(in DOMString data);
    nsIDOMCDATASection createCDATASection(in DOMString data) raises(DOMException);
    nsIDOMProcessingInstruction createProcessingInstruction(in DOMString target, in DOMString data) raises(DOMException);
    nsIDOMAttr createAttribute(in DOMString name) raises(DOMException);
    nsIDOMEntityReference createEntityReference(in DOMString name) raises(DOMException);
    nsIDOMNodeList getElementsByTagName(in DOMString tagname);
    nsIDOMNode importNode(in nsIDOMNode importedNode, in boolean deep) raises(DOMException);
    nsIDOMElement createElementNS(in DOMString namespaceURI, in DOMString qualifiedName) raises(DOMException);
    nsIDOMAttr createAttributeNS(in DOMString namespaceURI, in DOMString qualifiedName) raises(DOMException);
    nsIDOMNodeList getElementsByTagNameNS(in DOMString namespaceURI, in DOMString localName);
    nsIDOMElement getElementById(in DOMString elementId);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDOMEvent
///////////////////////////////////////////////////////////////////////////////


interface nsIDOMAbstractView;
interface nsIDOMEventTarget;
interface DOMTimeStamp;


[scriptable, uuid(a66b7b80-ff46-bd97-0080-5f8ae38add32)]
interface nsIDOMEvent : nsISupports
{
    const unsigned short CAPTURING_PHASE = 1;
    const unsigned short AT_TARGET = 2;
    const unsigned short BUBBLING_PHASE = 3;

    readonly attribute DOMString type;
    readonly attribute nsIDOMEventTarget target;
    readonly attribute nsIDOMEventTarget currentTarget;
    readonly attribute unsigned short eventPhase;
    readonly attribute boolean bubbles;
    readonly attribute boolean cancelable;
    readonly attribute DOMTimeStamp timeStamp;

    void stopPropagation();
    
    void preventDefault();
    
    void initEvent(in DOMString event_type_arg,
                   in boolean can_bubble_arg,
                   in boolean cancelable_arg);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDOMEventListener
///////////////////////////////////////////////////////////////////////////////


interface nsIDOMEvent;


[scriptable, function, uuid(df31c120-ded6-11d1-bd85-00805f8ae3f4)]
interface nsIDOMEventListener : nsISupports
{
    void handleEvent(in nsIDOMEvent event);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDOMEventTarget
///////////////////////////////////////////////////////////////////////////////


interface nsIDOMEvent;
interface nsIDOMEventListener;
interface DOMException;


[scriptable, uuid(1c773b30-d1cf-11d2-bd95-00805f8ae3f4)]
interface nsIDOMEventTarget : nsISupports
{
    void addEventListener(in DOMString type,
                          in nsIDOMEventListener listener,
                          in boolean use_capture);
                          
    void removeEventListener(
                          in DOMString type,
                          in nsIDOMEventListener listener,
                          in boolean use_capture);
                             
    boolean dispatchEvent(in nsIDOMEvent evt) raises(DOMException);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDOMHTMLElement
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(a6cf9085-15b3-11d2-932e-00805f8add32)]
interface nsIDOMHTMLElement : nsIDOMElement
{
    attribute DOMString id;
    attribute DOMString title;
    attribute DOMString lang;
    attribute DOMString dir;
    attribute DOMString className;
};










///////////////////////////////////////////////////////////////////////////////
//  nsIDOMHTMLLinkElement
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(a6cf9088-15b3-11d2-932e-00805f8add32)]
interface nsIDOMHTMLLinkElement : nsIDOMHTMLElement
{
    attribute boolean disabled;
    attribute DOMString charset;
    attribute DOMString href;
    attribute DOMString hreflang;
    attribute DOMString media;
    attribute DOMString rel;
    attribute DOMString rev;
    attribute DOMString target;
    attribute DOMString type;
};






///////////////////////////////////////////////////////////////////////////////
//  nsIDOMHTMLParamElement
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(a6cf90ad-15b3-11d2-932e-00805f8add32)]
interface nsIDOMHTMLParamElement : nsIDOMHTMLElement
{
    attribute DOMString name;
    attribute DOMString type;
    attribute DOMString value;
    attribute DOMString valueType;
};






///////////////////////////////////////////////////////////////////////////////
//  nsIDOMHTMLTextAreaElement
///////////////////////////////////////////////////////////////////////////////


interface nsIDOMHTMLFormElement;

[scriptable, uuid(a6cf9094-15b3-11d2-932e-00805f8add32)]
interface nsIDOMHTMLTextAreaElement : nsIDOMHTMLElement
{
    attribute DOMString defaultValue;
    readonly attribute nsIDOMHTMLFormElement form;
    attribute DOMString accessKey;
    attribute long cols;
    attribute boolean disabled;
    attribute DOMString name;
    attribute boolean readOnly;
    attribute long rows;
    attribute long tabIndex;
    readonly attribute DOMString type;
    attribute DOMString value;
    
    void blur();
    void focus();
    void select();
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDOMUIEvent
///////////////////////////////////////////////////////////////////////////////


interface nsIDOMAbstractView;

[scriptable, uuid(a6cf90c3-15b3-11d2-932e-00805f8add32)]
interface nsIDOMUIEvent : nsIDOMEvent
{
    readonly attribute nsIDOMAbstractView view;
    readonly attribute long detail;

    void initUIEvent(in DOMString type_arg,
                     in boolean can_bubble_arg,
                     in boolean cancelable_arg,
                     in nsIDOMAbstractView view_arg,
                     in long detail_arg);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDOMMouseEvent
///////////////////////////////////////////////////////////////////////////////


interface nsIDOMAbstractView;
interface nsIDOMEventTarget;


[scriptable, uuid(ff751edc-8b02-aae7-0010-8301838a3123)]
interface nsIDOMMouseEvent : nsIDOMUIEvent
{
    readonly attribute long screenX;
    readonly attribute long screenY;
    readonly attribute long clientX;
    readonly attribute long clientY;
    readonly attribute boolean ctrlKey;
    readonly attribute boolean shiftKey;
    readonly attribute boolean altKey;
    readonly attribute boolean metaKey;
    readonly attribute unsigned short button;
    readonly attribute nsIDOMEventTarget relatedTarget;
  
    void initMouseEvent(in DOMString type_arg,
                        in boolean can_bubble_arg,
                        in boolean cancelable_arg,
                        in nsIDOMAbstractView view_arg,
                        in long detail_arg,
                        in long screen_x_arg,
                        in long screen_y_arg,
                        in long client_x_arg,
                        in long client_y_arg,
                        in boolean ctrl_key_arg,
                        in boolean alt_key_arg,
                        in boolean shift_key_arg,
                        in boolean meta_key_arg,
                        in unsigned short button_arg,
                        in nsIDOMEventTarget related_target_arg);
};



[scriptable, uuid(028e0e6e-8b01-11d3-aae7-0010838a3123)]
interface nsIDOMKeyEvent : nsIDOMUIEvent
{
  const unsigned long DOM_VK_CANCEL         = 0x03;
  const unsigned long DOM_VK_HELP           = 0x06;
  const unsigned long DOM_VK_BACK_SPACE     = 0x08;
  const unsigned long DOM_VK_TAB            = 0x09;
  const unsigned long DOM_VK_CLEAR          = 0x0C;
  const unsigned long DOM_VK_RETURN         = 0x0D;
  const unsigned long DOM_VK_ENTER          = 0x0E;
  const unsigned long DOM_VK_SHIFT          = 0x10;
  const unsigned long DOM_VK_CONTROL        = 0x11;
  const unsigned long DOM_VK_ALT            = 0x12;
  const unsigned long DOM_VK_PAUSE          = 0x13;
  const unsigned long DOM_VK_CAPS_LOCK      = 0x14;
  const unsigned long DOM_VK_ESCAPE         = 0x1B;
  const unsigned long DOM_VK_SPACE          = 0x20;
  const unsigned long DOM_VK_PAGE_UP        = 0x21;
  const unsigned long DOM_VK_PAGE_DOWN      = 0x22;
  const unsigned long DOM_VK_END            = 0x23;
  const unsigned long DOM_VK_HOME           = 0x24;
  const unsigned long DOM_VK_LEFT           = 0x25;
  const unsigned long DOM_VK_UP             = 0x26;
  const unsigned long DOM_VK_RIGHT          = 0x27;
  const unsigned long DOM_VK_DOWN           = 0x28;
  const unsigned long DOM_VK_PRINTSCREEN    = 0x2C;
  const unsigned long DOM_VK_INSERT         = 0x2D;
  const unsigned long DOM_VK_DELETE         = 0x2E;

  // DOM_VK_0 - DOM_VK_9 match their ascii values
  const unsigned long DOM_VK_0              = 0x30;
  const unsigned long DOM_VK_1              = 0x31;
  const unsigned long DOM_VK_2              = 0x32;
  const unsigned long DOM_VK_3              = 0x33;
  const unsigned long DOM_VK_4              = 0x34;
  const unsigned long DOM_VK_5              = 0x35;
  const unsigned long DOM_VK_6              = 0x36;
  const unsigned long DOM_VK_7              = 0x37;
  const unsigned long DOM_VK_8              = 0x38;
  const unsigned long DOM_VK_9              = 0x39;

  const unsigned long DOM_VK_SEMICOLON      = 0x3B;
  const unsigned long DOM_VK_EQUALS         = 0x3D;

  // DOM_VK_A - DOM_VK_Z match their ascii values
  const unsigned long DOM_VK_A              = 0x41;
  const unsigned long DOM_VK_B              = 0x42;
  const unsigned long DOM_VK_C              = 0x43;
  const unsigned long DOM_VK_D              = 0x44;
  const unsigned long DOM_VK_E              = 0x45;
  const unsigned long DOM_VK_F              = 0x46;
  const unsigned long DOM_VK_G              = 0x47;
  const unsigned long DOM_VK_H              = 0x48;
  const unsigned long DOM_VK_I              = 0x49;
  const unsigned long DOM_VK_J              = 0x4A;
  const unsigned long DOM_VK_K              = 0x4B;
  const unsigned long DOM_VK_L              = 0x4C;
  const unsigned long DOM_VK_M              = 0x4D;
  const unsigned long DOM_VK_N              = 0x4E;
  const unsigned long DOM_VK_O              = 0x4F;
  const unsigned long DOM_VK_P              = 0x50;
  const unsigned long DOM_VK_Q              = 0x51;
  const unsigned long DOM_VK_R              = 0x52;
  const unsigned long DOM_VK_S              = 0x53;
  const unsigned long DOM_VK_T              = 0x54;
  const unsigned long DOM_VK_U              = 0x55;
  const unsigned long DOM_VK_V              = 0x56;
  const unsigned long DOM_VK_W              = 0x57;
  const unsigned long DOM_VK_X              = 0x58;
  const unsigned long DOM_VK_Y              = 0x59;
  const unsigned long DOM_VK_Z              = 0x5A;

  const unsigned long DOM_VK_CONTEXT_MENU   = 0x5D;

  const unsigned long DOM_VK_NUMPAD0        = 0x60;
  const unsigned long DOM_VK_NUMPAD1        = 0x61;
  const unsigned long DOM_VK_NUMPAD2        = 0x62;
  const unsigned long DOM_VK_NUMPAD3        = 0x63;
  const unsigned long DOM_VK_NUMPAD4        = 0x64;
  const unsigned long DOM_VK_NUMPAD5        = 0x65;
  const unsigned long DOM_VK_NUMPAD6        = 0x66;
  const unsigned long DOM_VK_NUMPAD7        = 0x67;
  const unsigned long DOM_VK_NUMPAD8        = 0x68;
  const unsigned long DOM_VK_NUMPAD9        = 0x69;
  const unsigned long DOM_VK_MULTIPLY       = 0x6A;
  const unsigned long DOM_VK_ADD            = 0x6B;
  const unsigned long DOM_VK_SEPARATOR      = 0x6C;
  const unsigned long DOM_VK_SUBTRACT       = 0x6D;
  const unsigned long DOM_VK_DECIMAL        = 0x6E;
  const unsigned long DOM_VK_DIVIDE         = 0x6F;
  const unsigned long DOM_VK_F1             = 0x70;
  const unsigned long DOM_VK_F2             = 0x71;
  const unsigned long DOM_VK_F3             = 0x72;
  const unsigned long DOM_VK_F4             = 0x73;
  const unsigned long DOM_VK_F5             = 0x74;
  const unsigned long DOM_VK_F6             = 0x75;
  const unsigned long DOM_VK_F7             = 0x76;
  const unsigned long DOM_VK_F8             = 0x77;
  const unsigned long DOM_VK_F9             = 0x78;
  const unsigned long DOM_VK_F10            = 0x79;
  const unsigned long DOM_VK_F11            = 0x7A;
  const unsigned long DOM_VK_F12            = 0x7B;
  const unsigned long DOM_VK_F13            = 0x7C;
  const unsigned long DOM_VK_F14            = 0x7D;
  const unsigned long DOM_VK_F15            = 0x7E;
  const unsigned long DOM_VK_F16            = 0x7F;
  const unsigned long DOM_VK_F17            = 0x80;
  const unsigned long DOM_VK_F18            = 0x81;
  const unsigned long DOM_VK_F19            = 0x82;
  const unsigned long DOM_VK_F20            = 0x83;
  const unsigned long DOM_VK_F21            = 0x84;
  const unsigned long DOM_VK_F22            = 0x85;
  const unsigned long DOM_VK_F23            = 0x86;
  const unsigned long DOM_VK_F24            = 0x87;

  const unsigned long DOM_VK_NUM_LOCK       = 0x90;
  const unsigned long DOM_VK_SCROLL_LOCK    = 0x91;

  const unsigned long DOM_VK_COMMA          = 0xBC;
  const unsigned long DOM_VK_PERIOD         = 0xBE;
  const unsigned long DOM_VK_SLASH          = 0xBF;
  const unsigned long DOM_VK_BACK_QUOTE     = 0xC0;
  const unsigned long DOM_VK_OPEN_BRACKET   = 0xDB;
  const unsigned long DOM_VK_BACK_SLASH     = 0xDC;
  const unsigned long DOM_VK_CLOSE_BRACKET  = 0xDD;
  const unsigned long DOM_VK_QUOTE          = 0xDE;

  const unsigned long DOM_VK_META           = 0xE0;

  readonly attribute unsigned long    charCode;
  readonly attribute unsigned long    keyCode;

  readonly attribute boolean          altKey;
  readonly attribute boolean          ctrlKey;
  readonly attribute boolean          shiftKey;
  readonly attribute boolean          metaKey;

  void                      initKeyEvent(in DOMString typeArg,
                                         in boolean canBubbleArg,
                                         in boolean cancelableArg,
                                         in nsIDOMAbstractView viewArg,
                                         in boolean ctrlKeyArg,
                                         in boolean altKeyArg,
                                         in boolean shiftKeyArg,
                                         in boolean metaKeyArg,
                                         in unsigned long keyCodeArg,
                                         in unsigned long charCodeArg);
};


///////////////////////////////////////////////////////////////////////////////
//  nsIDOMNamedNodeMap
///////////////////////////////////////////////////////////////////////////////


interface nsIDOMNode;
interface DOMException;


[scriptable, uuid(a6cf907b-15b3-11d2-932e-00805f8add32)]
interface nsIDOMNamedNodeMap : nsISupports
{
    nsIDOMNode getNamedItem(in DOMString name);
    nsIDOMNode setNamedItem(in nsIDOMNode arg) raises(DOMException);
    nsIDOMNode removeNamedItem(in DOMString name) raises(DOMException);
    nsIDOMNode item(in unsigned long index);
    
    readonly attribute unsigned long length;
    
    nsIDOMNode getNamedItemNS(in DOMString namespace_uri,
                              in DOMString local_name);
                                              
    nsIDOMNode setNamedItemNS(in nsIDOMNode arg)
                                      raises(DOMException);
    
    nsIDOMNode removeNamedItemNS(
                              in DOMString namespace_uri,
                              in DOMString local_name)
                                      raises(DOMException);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDOMNodeList
///////////////////////////////////////////////////////////////////////////////


interface nsIDOMNode;

[scriptable, uuid(a6cf907d-15b3-11d2-932e-00805f8add32)]
interface nsIDOMNodeList : nsISupports
{
    nsIDOMNode item(in unsigned long index);
    readonly attribute unsigned long length;
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDOMText
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(a6cf9082-15b3-11d2-932e-00805f8add32)]
interface nsIDOMText : nsIDOMCharacterData
{
    nsIDOMText splitText(in unsigned long offset)
                         raises(DOMException);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDOMWindow
///////////////////////////////////////////////////////////////////////////////


interface nsIDOMDocument;
interface nsIDOMBarProp;
interface nsIDOMWindowCollection;
interface nsISelection;

[scriptable, uuid(a6cf906b-15b3-11d2-932e-00805f8add32)]
interface nsIDOMWindow : nsISupports
{
    readonly attribute nsIDOMDocument document;
    readonly attribute nsIDOMWindow parent;
    readonly attribute nsIDOMWindow top;
    readonly attribute nsIDOMBarProp scrollbars;
    [noscript] readonly attribute nsIDOMWindowCollection frames;
    attribute DOMString name;
    [noscript] attribute float textZoom;
    readonly attribute long scrollX;
    readonly attribute long scrollY;

    void scrollTo(in long x_scroll, in long y_scroll);
    void scrollBy(in long x_scroll_diff, in long y_scroll_diff);
    nsISelection getSelection();
    void scrollByLines(in long num_lines);
    void scrollByPages(in long num_pages);
    void sizeToContent();
};






///////////////////////////////////////////////////////////////////////////////
//  nsIEmbeddingSiteWindow
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(3e5432cd-9568-4bd1-8cbe-d50aba110743)]
interface nsIEmbeddingSiteWindow : nsISupports
{
    const unsigned long DIM_FLAGS_POSITION = 1;
    const unsigned long DIM_FLAGS_SIZE_INNER = 2;
    const unsigned long DIM_FLAGS_SIZE_OUTER = 4;
    
    void setDimensions(in unsigned long flags,
                       in long x,
                       in long y,
                       in long cx,
                       in long cy);
                       
    void getDimensions(in unsigned long flags,
                       out long x,
                       out long y,
                       out long cx,
                       out long cy);
                       
    void setFocus();
    
    attribute boolean visibility;
    attribute wstring title;
    [noscript] readonly attribute voidPtr siteWindow;
};




///////////////////////////////////////////////////////////////////////////////
//  nsIEmbeddingSiteWindow2
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(e932bf55-0a64-4beb-923a-1f32d3661044)]
interface nsIEmbeddingSiteWindow2 : nsIEmbeddingSiteWindow
{
    void blur();
};




///////////////////////////////////////////////////////////////////////////////
//  nsIHelperAppLauncher
///////////////////////////////////////////////////////////////////////////////


interface nsIWebProgressListener2;
interface nsIMIMEInfo;

[scriptable, object, uuid(d9a19faf-497b-408c-b995-777d956b72c0)]
interface nsIHelperAppLauncher : nsICancelable
{
    readonly attribute nsIMIMEInfo MIMEInfo;
    readonly attribute nsIURI source;
    readonly attribute AString suggestedFileName;

    void saveToDisk(in nsIFile new_file_location,
                    in boolean remember_this_preference);

    void launchWithApplication(in nsIFile application,
                               in boolean remember_this_preference);

    void setWebProgressListener(in nsIWebProgressListener2 web_progress_listener);

    void closeProgressWindow();

    readonly attribute nsIFile targetFile;
    readonly attribute boolean targetFileIsExecutable;
    readonly attribute PRTime timeDownloadStarted;
    readonly attribute PRInt64 contentLength;
};



///////////////////////////////////////////////////////////////////////////////
//  nsIHelperAppLauncherDialog
///////////////////////////////////////////////////////////////////////////////


interface nsIHelperAppLauncher;
interface nsILocalFile;

[scriptable, object, uuid(f3704fdc-8ae6-4eba-a3c3-f02958ac0649)]
interface nsIHelperAppLauncherDialog : nsISupports
{
    const unsigned long REASON_CANTHANDLE = 0;
    const unsigned long REASON_SERVERREQUEST = 1;
    const unsigned long REASON_TYPESNIFFED = 2;
    
    void show(in nsIHelperAppLauncher launcher,
              in nsISupports windowContext,
              in unsigned long reason);

    nsILocalFile promptForSaveToFile(
              in nsIHelperAppLauncher launcher,
              in nsISupports windowContext,
              in wstring defaultFile,
              in wstring suggestedFileExtension,
              in boolean force_prompt);
};



///////////////////////////////////////////////////////////////////////////////
//  nsIInputStream
///////////////////////////////////////////////////////////////////////////////


%{C++

typedef NS_CALLBACK(nsWriteSegmentFun)(
        nsIInputStream* in_stream,
        void* closure,
        const char* from_segment,
        PRUint32 to_offset,
        PRUint32 count,
        PRUint32* write_count
);

%}
native nsWriteSegmentFun(nsWriteSegmentFun);

  
[scriptable, uuid(fa9c7f6c-61b3-11d4-9877-00c04fa0cf4a)]
interface nsIInputStream : nsISupports
{
     void close();
     unsigned long available();
     [noscript] unsigned long read(in charPtr buf, in unsigned long count);
     // this line wasn't compiling on VC6, so we'll use a void ptr for now
     //[noscript] unsigned long readSegments(in nsWriteSegmentFun writer, in voidPtr closure, in unsigned long count);
     [noscript] unsigned long readSegments(in voidPtr writer, in voidPtr closure, in unsigned long count);
     boolean isNonBlocking();
};




/**
 * nsIInputStreamChannel
 *
 * This interface provides methods to initialize an input stream channel.
 * The input stream channel serves as a data pump for an input stream.
 */
[scriptable, uuid(274c4d7a-2447-4ceb-a6de-80db1b83f5d2)]
interface nsIInputStreamChannel : nsISupports
{
    /**
     * Sets the URI for this channel.  This must be called before the
     * channel is opened, and it may only be called once.
     */
    void setURI(in nsIURI aURI);

    /**
     * Get/set the content stream
     *
     * This stream contains the data that will be pushed to the channel's
     * stream listener.  If the stream is non-blocking and supports the
     * nsIAsyncInputStream interface, then the stream will be read directly.
     * Otherwise, the stream will be read on a background thread.
     *
     * This attribute must be set before the channel is opened, and it may
     * only be set once.
     *
     * @throws NS_ERROR_IN_PROGRESS if the setter is called after the channel
     * has been opened.
     */
    attribute nsIInputStream contentStream;
};


///////////////////////////////////////////////////////////////////////////////
//  nsIIOService
///////////////////////////////////////////////////////////////////////////////


interface nsIProtocolHandler;
interface nsIChannel;


[scriptable, object, uuid(bddeda3f-9020-4d12-8c70-984ee9f7935e)]
interface nsIIOService : nsISupports
{
    nsIProtocolHandler getProtocolHandler(in string scheme);
    unsigned long getProtocolFlags(in string scheme);
    nsIURI newURI(in AUTF8String spec, in string origin_charset, in nsIURI base_uri);
    nsIURI newFileURI(in nsIFile file);
    nsIChannel newChannelFromURI(in nsIURI uri);
    nsIChannel newChannel(in AUTF8String spec,
                          in string origin_charset,
                          in nsIURI base_uri);
    
    attribute boolean offline;
    
    boolean allowPort(in long port, in string scheme);
    ACString extractScheme(in AUTF8String url_string);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIJSContextStack
///////////////////////////////////////////////////////////////////////////////


%{C++
struct JSContext;
%}

[ptr] native JSContext(JSContext);


[uuid(c67d8270-3189-11d3-9885-006008962422)]
interface nsIJSContextStack : nsISupports
{
    readonly attribute PRInt32 count;
    JSContext peek();
    JSContext pop();
    void push(in JSContext contxt);
};





///////////////////////////////////////////////////////////////////////////////
//  nsIPrefBranch
///////////////////////////////////////////////////////////////////////////////


/**
 * The nsIPrefBranch interface is used to manipulate the preferences data. This
 * object may be obtained from the preferences service (nsIPrefService) and
 * used to get and set default and/or user preferences across the application.
 *
 * This object is created with a "root" value which describes the base point in
 * the preferences "tree" from which this "branch" stems. Preferences are
 * accessed off of this root by using just the final portion of the preference.
 * For example, if this object is created with the root "browser.startup.",
 * the preferences "browser.startup.page", "browser.startup.homepage",
 * and "browser.startup.homepage_override" can be accessed by simply passing
 * "page", "homepage", or "homepage_override" to the various Get/Set methods.
 *
 * @see nsIPrefService
 */

[scriptable, uuid(56c35506-f14b-11d3-99d3-ddbfac2ccf65)]
interface nsIPrefBranch : nsISupports
{

  /**
   * Values describing the basic preference types.
   *
   * @see getPrefType
   */
  const long PREF_INVALID = 0;
  const long PREF_STRING = 32;
  const long PREF_INT = 64;
  const long PREF_BOOL = 128;

  /**
   * Called to get the root on which this branch is based, such as
   * "browser.startup."
   */
  readonly attribute string root;

  /**
   * Called to determine the type of a specific preference.
   *
   * @param aPrefName The preference to get the type of.
   *
   * @return long     A value representing the type of the preference. This
   *                  value will be PREF_STRING, PREF_INT, or PREF_BOOL.
   */
  long getPrefType(in string aPrefName);

  /**
   * Called to get the state of an individual boolean preference.
   *
   * @param aPrefName The boolean preference to get the state of.
   *
   * @return boolean  The value of the requested boolean preference.
   *
   * @see setBoolPref
   */
  boolean getBoolPref(in string aPrefName);

  /**
   * Called to set the state of an individual boolean preference.
   *
   * @param aPrefName The boolean preference to set the state of.
   * @param aValue    The boolean value to set the preference to.
   *
   * @return NS_OK The value was successfully set.
   * @return Other The value was not set or is the wrong type.
   *
   * @see getBoolPref
   */
  void setBoolPref(in string aPrefName, in long aValue);

  /**
   * Called to get the state of an individual string preference.
   *
   * @param aPrefName The string preference to retrieve.
   *
   * @return string   The value of the requested string preference.
   *
   * @see setCharPref
   */
  string getCharPref(in string aPrefName);

  /**
   * Called to set the state of an individual string preference.
   *
   * @param aPrefName The string preference to set.
   * @param aValue    The string value to set the preference to.
   *
   * @return NS_OK The value was successfully set.
   * @return Other The value was not set or is the wrong type.
   *
   * @see getCharPref
   */
  void setCharPref(in string aPrefName, in string aValue);

  /**
   * Called to get the state of an individual integer preference.
   *
   * @param aPrefName The integer preference to get the value of.
   *
   * @return long     The value of the requested integer preference.
   *
   * @see setIntPref
   */
  long getIntPref(in string aPrefName);

  /**
   * Called to set the state of an individual integer preference.
   *
   * @param aPrefName The integer preference to set the value of.
   * @param aValue    The integer value to set the preference to.
   *
   * @return NS_OK The value was successfully set.
   * @return Other The value was not set or is the wrong type.
   *
   * @see getIntPref
   */
  void setIntPref(in string aPrefName, in long aValue);

  /**
   * Called to get the state of an individual complex preference. A complex
   * preference is a preference which represents an XPCOM object that can not
   * be easily represented using a standard boolean, integer or string value.
   *
   * @param aPrefName The complex preference to get the value of.
   * @param aType     The XPCOM interface that this complex preference
   *                  represents. Interfaces currently supported are:
   *                    - nsILocalFile
   *                    - nsISupportsString (UniChar)
   *                    - nsIPrefLocalizedString (Localized UniChar)
   * @param aValue    The XPCOM object into which to the complex preference 
   *                  value should be retrieved.
   *
   * @return NS_OK The value was successfully retrieved.
   * @return Other The value does not exist or is the wrong type.
   *
   * @see setComplexValue
   */
  void getComplexValue(in string aPrefName, in nsIIDRef aType,
                       [iid_is(aType), retval] out nsQIResult aValue);

  /**
   * Called to set the state of an individual complex preference. A complex
   * preference is a preference which represents an XPCOM object that can not
   * be easily represented using a standard boolean, integer or string value.
   *
   * @param aPrefName The complex preference to set the value of.
   * @param aType     The XPCOM interface that this complex preference
   *                  represents. Interfaces currently supported are:
   *                    - nsILocalFile
   *                    - nsISupportsString (UniChar)
   *                    - nsIPrefLocalizedString (Localized UniChar)
   * @param aValue    The XPCOM object from which to set the complex preference 
   *                  value.
   *
   * @return NS_OK The value was successfully set.
   * @return Other The value was not set or is the wrong type.
   *
   * @see getComplexValue
   */
  void setComplexValue(in string aPrefName, in nsIIDRef aType, in nsISupports aValue);

  /**
   * Called to clear a user set value from a specific preference. This will, in
   * effect, reset the value to the default value. If no default value exists
   * the preference will cease to exist.
   *
   * @param aPrefName The preference to be cleared.
   *
   * @note
   * This method does nothing if this object is a default branch.
   *
   * @return NS_OK The user preference was successfully cleared.
   * @return Other The preference does not exist or have a user set value.
   */
  void clearUserPref(in string aPrefName);

  /**
   * Called to lock a specific preference. Locking a preference will cause the
   * preference service to always return the default value regardless of
   * whether there is a user set value or not.
   *
   * @param aPrefName The preference to be locked.
   *
   * @note
   * This method can be called on either a default or user branch but, in
   * effect, always operates on the default branch.
   *
   * @return NS_OK The preference was successfully locked.
   * @return Other The preference does not exist or an error occurred.
   *
   * @see unlockPref
   */
  void lockPref(in string aPrefName);

  /**
   * Called to check if a specific preference has a user value associated to
   * it.
   *
   * @param aPrefName The preference to be tested.
   *
   * @note
   * This method can be called on either a default or user branch but, in
   * effect, always operates on the user branch.
   *
   * @note
   * If a preference was manually set to a value that equals the default value,
   * then the preference no longer has a user set value, i.e. it is
   * considered reset to its default value.
   * In particular, this method will return false for such a preference and
   * the preference will not be saved to a file by nsIPrefService.savePrefFile.
   *
   * @return boolean  true  The preference has a user set value.
   *                  false The preference only has a default value.
   */
  boolean prefHasUserValue(in string aPrefName);

  /**
   * Called to check if a specific preference is locked. If a preference is
   * locked calling its Get method will always return the default value.
   *
   * @param aPrefName The preference to be tested.
   *
   * @note
   * This method can be called on either a default or user branch but, in
   * effect, always operates on the default branch.
   *
   * @return boolean  true  The preference is locked.
   *                  false The preference is not locked.
   *
   * @see lockPref
   * @see unlockPref
   */
  boolean prefIsLocked(in string aPrefName);

  /**
   * Called to unlock a specific preference. Unlocking a previously locked 
   * preference allows the preference service to once again return the user set
   * value of the preference.
   *
   * @param aPrefName The preference to be unlocked.
   *
   * @note
   * This method can be called on either a default or user branch but, in
   * effect, always operates on the default branch.
   *
   * @return NS_OK The preference was successfully unlocked.
   * @return Other The preference does not exist or an error occurred.
   *
   * @see lockPref
   */
  void    unlockPref(in string aPrefName);


  /**
   * Called to remove all of the preferences referenced by this branch.
   *
   * @param aStartingAt The point on the branch at which to start the deleting
   *                    preferences. Pass in "" to remove all preferences
   *                    referenced by this branch.
   *
   * @note
   * This method can be called on either a default or user branch but, in
   * effect, always operates on both.
   *
   * @return NS_OK The preference(s) were successfully removed.
   * @return Other The preference(s) do not exist or an error occurred.
   */
  void deleteBranch(in string aStartingAt);

  /**
   * Returns an array of strings representing the child preferences of the
   * root of this branch.
   * 
   * @param aStartingAt The point on the branch at which to start enumerating
   *                    the child preferences. Pass in "" to enumerate all
   *                    preferences referenced by this branch.
   * @param aCount      Receives the number of elements in the array.
   * @param aChildArray Receives the array of child preferences.
   *
   * @note
   * This method can be called on either a default or user branch but, in
   * effect, always operates on both.
   *
   * @return NS_OK The preference list was successfully retrieved.
   * @return Other The preference(s) do not exist or an error occurred.
   */
  void getChildList(in string aStartingAt,
                    [optional] out unsigned long aCount,
                    [array, size_is(aCount), retval] out string aChildArray);

  /**
   * Called to reset all of the preferences referenced by this branch to their
   * default values.
   *
   * @param aStartingAt The point on the branch at which to start the resetting
   *                    preferences to their default values. Pass in "" to
   *                    reset all preferences referenced by this branch.
   *
   * @note
   * This method can be called on either a default or user branch but, in
   * effect, always operates on the user branch.
   *
   * @return NS_OK The preference(s) were successfully reset.
   * @return Other The preference(s) do not exist or an error occurred.
   */
  void resetBranch(in string aStartingAt);

};


%{C++

#define NS_PREFBRANCH_CONTRACTID "@mozilla.org/preferencesbranch;1"
#define NS_PREFBRANCH_CLASSNAME "Preferences Branch"

%}


///////////////////////////////////////////////////////////////////////////////
//  nsIPrefService
///////////////////////////////////////////////////////////////////////////////


interface nsIFile;

/**
 * The nsIPrefService interface is the main entry point into the back end
 * preferences management library. The preference service is directly
 * responsible for the management of the preferences files and also facilitates
 * access to the preference branch object which allows the direct manipulation
 * of the preferences themselves.
 *
 * @see nsIPrefBranch
 * 
 * @status FROZEN
 */

[scriptable, uuid(decb9cc7-c08f-4ea5-be91-a8fc637ce2d2)]
interface nsIPrefService : nsISupports
{
  /**
   * Called to read in the preferences specified in a user preference file.
   *
   * @param aFile The file to be read.
   *
   * @note
   * If nsnull is passed in for the aFile parameter the default preferences
   * file(s) [prefs.js, user.js] will be read and processed.
   *
   * @return NS_OK File was read and processed.
   * @return Other File failed to read or contained invalid data.
   *
   * @see savePrefFile
   * @see nsIFile
   */
  void readUserPrefs(in nsIFile aFile);

  /**
   * Called to completely flush and re-initialize the preferences system.
   *
   * @return NS_OK The preference service was re-initialized correctly.
   * @return Other The preference service failed to restart correctly.
   */
  void resetPrefs();

  /**
   * Called to reset all preferences with user set values back to the
   * application default values.
   *
   * @return NS_OK Always.
   */
  void resetUserPrefs();

  /**
   * Called to write current preferences state to a file.
   *
   * @param aFile The file to be written.
   *
   * @note
   * If nsnull is passed in for the aFile parameter the preference data is
   * written out to the current preferences file (usually prefs.js.)
   *
   * @return NS_OK File was written.
   * @return Other File failed to write.
   *
   * @see readUserPrefs
   * @see nsIFile
   */
  void savePrefFile(in nsIFile aFile);


  /**
   * Call to get a Preferences "Branch" which accesses user preference data.
   * Using a Set method on this object will always create or set a user
   * preference value. When using a Get method a user set value will be
   * returned if one exists, otherwise a default value will be returned.
   *
   * @param aPrefRoot The preference "root" on which to base this "branch".
   *                  For example, if the root "browser.startup." is used, the
   *                  branch will be able to easily access the preferences
   *                  "browser.startup.page", "browser.startup.homepage", or
   *                  "browser.startup.homepage_override" by simply requesting
   *                  "page", "homepage", or "homepage_override". nsnull or "" 
   *                  may be used to access to the entire preference "tree".
   *
   * @return nsIPrefBranch The object representing the requested branch.
   *
   * @see getDefaultBranch
   */
  nsIPrefBranch getBranch(in string aPrefRoot);

  /**
   * Call to get a Preferences "Branch" which accesses only the default 
   * preference data. Using a Set method on this object will always create or
   * set a default preference value. When using a Get method a default value
   * will always be returned.
   *
   * @param aPrefRoot The preference "root" on which to base this "branch".
   *                  For example, if the root "browser.startup." is used, the
   *                  branch will be able to easily access the preferences
   *                  "browser.startup.page", "browser.startup.homepage", or
   *                  "browser.startup.homepage_override" by simply requesting
   *                  "page", "homepage", or "homepage_override". nsnull or "" 
   *                  may be used to access to the entire preference "tree".
   *
   * @note
   * Few consumers will want to create default branch objects. Many of the
   * branch methods do nothing on a default branch because the operations only
   * make sense when applied to user set preferences.
   *
   * @return nsIPrefBranch The object representing the requested default branch.
   *
   * @see getBranch
   */
  nsIPrefBranch getDefaultBranch(in string aPrefRoot);

};

%{C++

#define NS_PREFSERVICE_CID                             \
  { /* {1cd91b88-1dd2-11b2-92e1-ed22ed298000} */       \
    0x1cd91b88,                                        \
    0x1dd2,                                            \
    0x11b2,                                            \
    { 0x92, 0xe1, 0xed, 0x22, 0xed, 0x29, 0x80, 0x00 } \
  }

#define NS_PREFSERVICE_CONTRACTID "@mozilla.org/preferences-service;1"
#define NS_PREFSERVICE_CLASSNAME "Preferences Server"

/**
 * Notification sent before reading the default user preferences files.
 */
#define NS_PREFSERVICE_READ_TOPIC_ID "prefservice:before-read-userprefs"

/**
 * Notification sent when resetPrefs has been called, but before the actual
 * reset process occurs.
 */
#define NS_PREFSERVICE_RESET_TOPIC_ID "prefservice:before-reset"

/**
 * Notification sent when after reading app-provided default
 * preferences, but before user profile override defaults or extension
 * defaults are loaded.
 */
#define NS_PREFSERVICE_APPDEFAULTS_TOPIC_ID "prefservice:after-app-defaults"

%}

///////////////////////////////////////////////////////////////////////////////
//  nsIWebBrowserPrint
///////////////////////////////////////////////////////////////////////////////

interface nsIPrintSettings;
interface nsIDOMWindow;
interface nsIWebProgressListener;

[scriptable, uuid(9a7ca4b0-fbba-11d4-a869-00105a183419)]
interface nsIWebBrowserPrint : nsISupports
{
    const short PRINTPREVIEW_GOTO_PAGENUM = 0;
    const short PRINTPREVIEW_PREV_PAGE = 1;
    const short PRINTPREVIEW_NEXT_PAGE = 2;
    const short PRINTPREVIEW_HOME = 3;
    const short PRINTPREVIEW_END = 4;

    readonly attribute nsIPrintSettings globalPrintSettings;
    readonly attribute nsIPrintSettings currentPrintSettings;
    readonly attribute nsIDOMWindow currentChildDOMWindow;
    readonly attribute boolean doingPrint;
    readonly attribute boolean doingPrintPreview;
    readonly attribute boolean isFramesetDocument;
    readonly attribute boolean isFramesetFrameSelected;
    readonly attribute boolean isIFrameSelected;
    readonly attribute boolean isRangeSelection;
    readonly attribute long printPreviewNumPages;

    void print(in nsIPrintSettings thePrintSettings,
               in nsIWebProgressListener WPListener);

    void printPreview(
                in nsIPrintSettings thePrintSettings,
                in nsIDOMWindow childDOMWin,
                in nsIWebProgressListener WPListener);

    void printPreviewNavigate(in short navType, in long pageNum);
    void cancel();
    void enumerateDocumentNames(
                out PRUint32 count,
                [retval, array, size_is(count)] out wstring result);
                
    void exitPrintPreview();
};


[scriptable, uuid(841387C8-72E6-484b-9296-BF6EEA80D58A)]
interface nsIPrintSettingsService : nsISupports
{
    readonly attribute nsIPrintSettings globalPrintSettings;
    readonly attribute nsIPrintSettings newPrintSettings;
    readonly attribute wstring defaultPrinterName;

    void initPrintSettingsFromPrinter(in wstring printer_name,
                                      in nsIPrintSettings print_settings);
                                      
    void initPrintSettingsFromPrefs(in nsIPrintSettings print_settings,
                                    in boolean use_printer_name_prefix,
                                    in unsigned long flags);
                                    
    void savePrintSettingsToPrefs(in nsIPrintSettings print_settings,
                                  in boolean user_printer_name_prefix,
                                  in unsigned long flags);
};


///////////////////////////////////////////////////////////////////////////////
//  nsIPrintSettings
///////////////////////////////////////////////////////////////////////////////

/*
%{ C++
#include "nsMargin.h"
%}
*/

/**
 * Native types
 */
/*
  [ref] native nsNativeIntMarginRef(nsIntMargin);
*/
  
interface nsIPrintSession;

/**
 * Simplified graphics interface for JS rendering.
 *
 * @status UNDER_REVIEW
 */
[scriptable, uuid(343700dd-078b-42b6-a809-b9c1d7e951d0)]

interface nsIPrintSettings : nsISupports
{
  /**
   * PrintSettings to be Saved Navigation Constants
   */
  const unsigned long kInitSaveOddEvenPages   = 0x00000001;
  const unsigned long kInitSaveHeaderLeft     = 0x00000002;
  const unsigned long kInitSaveHeaderCenter   = 0x00000004;
  const unsigned long kInitSaveHeaderRight    = 0x00000008;
  const unsigned long kInitSaveFooterLeft     = 0x00000010;
  const unsigned long kInitSaveFooterCenter   = 0x00000020;
  const unsigned long kInitSaveFooterRight    = 0x00000040;
  const unsigned long kInitSaveBGColors       = 0x00000080;
  const unsigned long kInitSaveBGImages       = 0x00000100;
  const unsigned long kInitSavePaperSize      = 0x00000200;
  /* Flag 0x00000400 is unused */
  /* Flag 0x00000800 is unused */
  /* Flag 0x00001000 is unused */
  const unsigned long kInitSavePaperData      = 0x00002000;
  const unsigned long kInitSaveUnwriteableMargins = 0x00004000;
  const unsigned long kInitSaveEdges          = 0x00008000;

  const unsigned long kInitSaveReversed       = 0x00010000;
  const unsigned long kInitSaveInColor        = 0x00020000;
  const unsigned long kInitSaveOrientation    = 0x00040000;
  const unsigned long kInitSavePrintCommand   = 0x00080000;
  const unsigned long kInitSavePrinterName    = 0x00100000;
  const unsigned long kInitSavePrintToFile    = 0x00200000;
  const unsigned long kInitSaveToFileName     = 0x00400000;
  const unsigned long kInitSavePageDelay      = 0x00800000;
  const unsigned long kInitSaveMargins        = 0x01000000;
  const unsigned long kInitSaveNativeData     = 0x02000000;
  const unsigned long kInitSavePlexName       = 0x04000000;
  const unsigned long kInitSaveShrinkToFit    = 0x08000000;
  const unsigned long kInitSaveScaling        = 0x10000000;
  const unsigned long kInitSaveColorspace     = 0x20000000;
  const unsigned long kInitSaveResolutionName = 0x40000000;
  const unsigned long kInitSaveDownloadFonts  = 0x80000000;
  const unsigned long kInitSaveAll            = 0xFFFFFFFF;

  /* Print Option Flags for Bit Field*/
  const long kPrintOddPages     = 0x00000001;
  const long kPrintEvenPages    = 0x00000002;
  const long kEnableSelectionRB = 0x00000004;

  /* Print Range Enums */
  const long kRangeAllPages           = 0;
  const long kRangeSpecifiedPageRange = 1;
  const long kRangeSelection          = 2;
  const long kRangeFocusFrame         = 3;

  /* Justification Enums */
  const long kJustLeft   = 0;
  const long kJustCenter = 1;
  const long kJustRight  = 2;

  /**
   * FrameSet Default Type Constants
   */
  const short kUseInternalDefault    = 0;
  const short kUseSettingWhenPossible = 1;

  /**
   * Page Size Type Constants
   */
  const short kPaperSizeNativeData  = 0;
  const short kPaperSizeDefined     = 1;

  /**
   * Page Size Unit Constants
   */
  const short kPaperSizeInches      = 0;
  const short kPaperSizeMillimeters = 1;

  /**
   * Orientation Constants
   */
  const short kPortraitOrientation  = 0;
  const short kLandscapeOrientation = 1;

  /**
   * Print Frame Constants
   */
  const short kNoFrames      = 0;
  const short kFramesAsIs    = 1;
  const short kSelectedFrame = 2;
  const short kEachFrameSep  = 3;

  /**
   * How to Enable Frame Set Printing Constants
   */
  const short kFrameEnableNone        = 0;
  const short kFrameEnableAll         = 1;
  const short kFrameEnableAsIsAndEach = 2;

  /**
   * Output file format
   */
  const short kOutputFormatNative = 0;
  const short kOutputFormatPS     = 1;
  const short kOutputFormatPDF    = 2;

  /**
   * Set PrintOptions 
   */
  void SetPrintOptions(in PRInt32 aType, in PRBool aTurnOnOff);

  /**
   * Get PrintOptions 
   */
  PRBool GetPrintOptions(in PRInt32 aType);

  /**
   * Set PrintOptions Bit field
   */
  PRInt32 GetPrintOptionsBits();

  /**
   * Get the page size in twips, considering the
   * orientation (portrait or landscape).
   */
  void GetEffectivePageSize(out double aWidth, out double aHeight);

  /**
   * Makes a new copy
   */
    nsIPrintSettings clone();

  /**
   * Assigns the internal values from the "in" arg to the current object
   */
    void assign(in nsIPrintSettings aPS);

  /**
   * Data Members
   */
  [noscript] attribute nsIPrintSession printSession; /* We hold a weak reference */

  attribute long    startPageRange;    
  attribute long    endPageRange;    

  /**
   * The edge measurements define the positioning of the headers
   * and footers on the page. They're measured as an offset from
   * the "unwriteable margin" (described below).
   */
  attribute double  edgeTop;     /*  these are in inches */
  attribute double  edgeLeft;
  attribute double  edgeBottom;
  attribute double  edgeRight;

  /**
   * The margins define the positioning of the content on the page.
   * They're treated as an offset from the "unwriteable margin"
   * (described below).
   */
  attribute double  marginTop;     /*  these are in inches */
  attribute double  marginLeft;
  attribute double  marginBottom;
  attribute double  marginRight;
  /**
   * The unwriteable margin defines the printable region of the paper, creating
   * an invisible border from which the edge and margin attributes are measured.
   */
  attribute double  unwriteableMarginTop;     /*  these are in inches */
  attribute double  unwriteableMarginLeft;
  attribute double  unwriteableMarginBottom;
  attribute double  unwriteableMarginRight;

  attribute double  scaling;      /* values 0.0 - 1.0 */
  attribute boolean printBGColors; /* Print Background Colors */
  attribute boolean printBGImages; /* Print Background Images */

  attribute short   printRange; 

  attribute wstring title;
  attribute wstring docURL;

  attribute wstring headerStrLeft;
  attribute wstring headerStrCenter;
  attribute wstring headerStrRight;

  attribute wstring footerStrLeft;
  attribute wstring footerStrCenter;
  attribute wstring footerStrRight;

  attribute short   howToEnableFrameUI;  /* indicates how to enable the frameset UI            */
  attribute boolean isCancelled;         /* indicates whether the print job has been cancelled */
  attribute short   printFrameTypeUsage; /* indicates whether to use the interal value or not  */
  attribute short   printFrameType;
  attribute boolean printSilent;	     /* print without putting up the dialog */
  attribute boolean shrinkToFit;	     /* shrinks content to fit on page      */
  attribute boolean showPrintProgress;   /* indicates whether the progress dialog should be shown */

  /* Additional XP Related */
  attribute wstring paperName;     /* name of paper */
  attribute short   paperSizeType; /* use native data or is defined here */
  attribute short   paperData;     /* native data value */
  attribute double  paperWidth;    /* width of the paper in inches or mm */
  attribute double  paperHeight;   /* height of the paper in inches or mm */
  attribute short   paperSizeUnit; /* paper is in inches or mm */

  attribute wstring plexName;      /* name of plex mode (like "simplex", "duplex",
                                    * "tumble" and various custom values) */

  attribute wstring colorspace;    /* device-specific name of colorspace, overrides |printInColor| */
  attribute wstring resolutionName;/* device-specific identifer of resolution or quality
                                    * (like "600", "600x300", "600x300x12", "high-res",
                                    * "med-res". "low-res", etc.) */
  attribute boolean downloadFonts; /* enable font download to printer? */

  attribute boolean printReversed;
  attribute boolean printInColor;  /* a false means grayscale */
  attribute long    orientation;   /*  see orientation consts */
  attribute wstring printCommand;
  attribute long    numCopies;

  attribute wstring printerName;   /* name of destination printer */

  attribute boolean printToFile;
  attribute wstring toFileName;
  attribute short   outputFormat;

  attribute long    printPageDelay; /* in milliseconds */
  
  /* initialize helpers */
  /**
   * This attribute tracks whether the PS has been initialized 
   * from a printer specified by the "printerName" attr. 
   * If a different name is set into the "printerName" 
   * attribute than the one it was initialized with the PS
   * will then get intialized from that printer.
   */
  attribute boolean isInitializedFromPrinter;

  /**
   * This attribute tracks whether the PS has been initialized 
   * from prefs. If a different name is set into the "printerName" 
   * attribute than the one it was initialized with the PS
   * will then get intialized from prefs again.
   */
  attribute boolean isInitializedFromPrefs;

    /**
     * Helper functions that require native types have been excluded
     * following Kirix's lead.  Hope this still works...
     */

  /* C++ Helper Functions */
  /*
  [noscript] void SetMarginInTwips(in nsNativeIntMarginRef aMargin);
  [noscript] void SetEdgeInTwips(in nsNativeIntMarginRef aEdge);
  [noscript] void GetMarginInTwips(in nsNativeIntMarginRef aMargin);
  [noscript] void GetEdgeInTwips(in nsNativeIntMarginRef aEdge);
  */

  /**
   * We call this function so that anything that requires a run of the event loop
   * can do so safely. The print dialog runs the event loop but in silent printing
   * that doesn't happen.
   *
   * Either this or ShowPrintDialog (but not both) MUST be called by the print engine
   * before printing, otherwise printing can fail on some platforms.
   */
  [noscript] void SetupSilentPrinting();

  /**
   * Sets/Gets the "unwriteable margin" for the page format.  This defines
   * the boundary from which we'll measure the EdgeInTwips and MarginInTwips 
   * attributes, to place the headers and content, respectively.
   *
   * Note: Implementations of SetUnwriteableMarginInTwips should handle
   * negative margin values by falling back on the system default for
   * that margin.
   */
/*
  [noscript] void SetUnwriteableMarginInTwips(in nsNativeIntMarginRef aEdge);
  [noscript] void GetUnwriteableMarginInTwips(in nsNativeIntMarginRef aEdge);
*/
};




///////////////////////////////////////////////////////////////////////////////
//  nsIPromptService
///////////////////////////////////////////////////////////////////////////////


interface nsIDOMWindow;

[scriptable, uuid(1630c61a-325e-49ca-8759-a31b16c47aa5)]
interface nsIPromptService : nsISupports
{
    void alert(in nsIDOMWindow parent,
               in wstring dialog_title,
               in wstring text);
               
    void alertCheck(
               in nsIDOMWindow parent,
               in wstring dialog_title,
               in wstring text,
               in wstring check_msg,
               inout boolean check_state);
               
    boolean confirm(
               in nsIDOMWindow parent,
               in wstring dialog_title,
               in wstring text);
               
    boolean confirmCheck(
               in nsIDOMWindow parent,
               in wstring dialog_title,
               in wstring text,
               in wstring check_msg,
               inout boolean check_state);
        
    const unsigned long BUTTON_POS_0 = 1;
    const unsigned long BUTTON_POS_1 = 256;
    const unsigned long BUTTON_POS_2 = 65536;
    const unsigned long BUTTON_TITLE_OK = 1;
    const unsigned long BUTTON_TITLE_CANCEL = 2;
    const unsigned long BUTTON_TITLE_YES = 3;
    const unsigned long BUTTON_TITLE_NO = 4;
    const unsigned long BUTTON_TITLE_SAVE = 5;
    const unsigned long BUTTON_TITLE_DONT_SAVE = 6;
    const unsigned long BUTTON_TITLE_REVERT = 7;
    const unsigned long BUTTON_TITLE_IS_STRING = 127;
    const unsigned long BUTTON_POS_0_DEFAULT = 0;
    const unsigned long BUTTON_POS_1_DEFAULT = 16777216;
    const unsigned long BUTTON_POS_2_DEFAULT = 33554432;
    const unsigned long BUTTON_DELAY_ENABLE = 67108864;
    const unsigned long STD_OK_CANCEL_BUTTONS = 513;
    const unsigned long STD_YES_NO_BUTTONS = 1027;
    
    
    PRInt32 confirmEx(
               in nsIDOMWindow parent,
               in wstring dialog_title,
               in wstring text,
               in unsigned long button_flags,
               in wstring button0_title,
               in wstring button1_title,
               in wstring button2_title,
               in wstring check_msg,
               inout boolean check_state);

    boolean prompt(
               in nsIDOMWindow parent,
               in wstring dialog_title,
               in wstring text,
               inout wstring value,
               in wstring check_msg,
               inout boolean check_state);

    boolean promptUsernameAndPassword(
               in nsIDOMWindow parent,
               in wstring dialog_title,
               in wstring text,
               inout wstring username,
               inout wstring password,
               in wstring check_msg,
               inout boolean check_state);

    boolean promptPassword(
               in nsIDOMWindow parent,
               in wstring dialog_title,
               in wstring text,
               inout wstring password,
               in wstring check_msg,
               inout boolean check_state);

    boolean select(
               in nsIDOMWindow parent,
               in wstring dialog_title,
               in wstring text,
               in PRUint32 count,
               [array, size_is(count)] in wstring select_list,
               out long out_selection);
};


interface nsIAuthInformation;
interface nsIAuthPromptCallback;

[scriptable, uuid(cf86d196-dbee-4482-9dfa-3477aa128319)]
interface nsIPromptService2 : nsIPromptService
{
    boolean promptAuth(
                in nsIDOMWindow parent,
                in nsIChannel channel,
                in PRUint32 level,
                in nsIAuthInformation auth_info,
                in wstring checkbox_label,
                inout boolean check_value);

    nsICancelable asyncPromptAuth(
                in nsIDOMWindow parent,
                in nsIChannel channel,
                in nsIAuthPromptCallback callbck,
                in nsISupports contxt,
                in PRUint32 level,
                in nsIAuthInformation auth_info,
                in wstring checkbox_label,
                inout boolean check_value);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIAuthInformation
///////////////////////////////////////////////////////////////////////////////

[scriptable, uuid(0d73639c-2a92-4518-9f92-28f71fea5f20)]
interface nsIAuthInformation : nsISupports
{
    const PRUint32 AUTH_HOST = 1;
    const PRUint32 AUTH_PROXY = 2;
    const PRUint32 NEED_DOMAIN = 4;
    const PRUint32 ONLY_PASSWORD = 8;

    readonly attribute unsigned long flags;
    readonly attribute AString realm;
    readonly attribute AUTF8String authenticationScheme;
    attribute AString username;
    attribute AString password;
    attribute AString domain;
};



///////////////////////////////////////////////////////////////////////////////
//  nsIProperties
///////////////////////////////////////////////////////////////////////////////

[scriptable, uuid(78650582-4e93-4b60-8e85-26ebd3eb14ca)]
interface nsIProperties : nsISupports
{
    void get(in string prop_name,
             in nsIIDRef iid,
             [iid_is(iid), retval] out nsQIResult result);

    void set(in string prop_name,
             in nsISupports value);

    boolean has(in string prop_name);
    
    void undefine(in string prop_name);

    void getKeys(out PRUint32 count,
                 [array, size_is(count), retval] out string keys);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIRequestObserver
///////////////////////////////////////////////////////////////////////////////


interface nsIRequest;


[scriptable, uuid(fd91e2e0-1481-11d3-9333-00104ba0fd40)]
interface nsIRequestObserver : nsISupports
{
    void onStartRequest(in nsIRequest request,
                        in nsISupports contxt);
                        
    void onStopRequest(in nsIRequest request,
                       in nsISupports contxt,
                       in nsresult status_code);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIServiceManager
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(8bb35ed9-e332-462d-9155-4a002ab5c958)]
interface nsIServiceManager : nsISupports
{
    void getService(in nsCIDRef class_id,
                    in nsIIDRef iid,
                    [iid_is(iid), retval] out nsQIResult result);
                    
    void getServiceByContractID(
                    in string contract_id,
                    in nsIIDRef iid,
                    [iid_is(iid), retval] out nsQIResult result);
                    
    boolean isServiceInstantiated(
                    in nsCIDRef class_id,
                    in nsIIDRef iid);
                    
    boolean isServiceInstantiatedByContractID(
                    in string contract_id,
                    in nsIIDRef iid);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIStreamListener
///////////////////////////////////////////////////////////////////////////////


interface nsIRequest;
interface nsIInputStream;


[scriptable, uuid(1a637020-1482-11d3-9333-00104ba0fd40)]
interface nsIStreamListener : nsIRequestObserver
{
    void onDataAvailable(
            in nsIRequest request,
            in nsISupports contxt,
            in nsIInputStream input_stream,
            in unsigned long offset,
            in unsigned long count);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIStringInputStream
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(450cd2d4-f0fd-424d-b365-b1251f80fd53)]
interface nsIStringInputStream : nsIInputStream
{
    void setData(in string data, in long dataLen);
    [noscript] void adoptData(in charPtr data, in long data_len);
    [noscript] void shareData(in string data, in long data_len);
};




///////////////////////////////////////////////////////////////////////////////
//  nsITooltipListener
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(44b78386-1dd2-11b2-9ad2-e4eee2ca1916)]
interface nsITooltipListener : nsISupports
{
    void onShowTooltip(in long x_coords,
                       in long y_coords,
                       in wstring tip_text);
    void onHideTooltip();
};




///////////////////////////////////////////////////////////////////////////////
//  nsIWebProgressListener
///////////////////////////////////////////////////////////////////////////////


interface nsIWebProgress;
interface nsIRequest;

[scriptable, uuid(570f39d1-efd0-11d3-b093-00a024ffc08c)]
interface nsIWebProgressListener : nsISupports
{
    const unsigned long STATE_START = 1;
    const unsigned long STATE_REDIRECTING = 2;
    const unsigned long STATE_TRANSFERRING = 4;
    const unsigned long STATE_NEGOTIATING = 8;
    const unsigned long STATE_STOP = 16;

    const unsigned long STATE_IS_REQUEST = 65536;
    const unsigned long STATE_IS_DOCUMENT = 131072;
    const unsigned long STATE_IS_NETWORK = 262144;
    const unsigned long STATE_IS_WINDOW = 524288;
    
    const unsigned long STATE_RESTORING = 16777216;

    const unsigned long STATE_IS_INSECURE = 4;
    const unsigned long STATE_IS_BROKEN = 1;
    const unsigned long STATE_IS_SECURE = 2;

    const unsigned long STATE_SECURE_HIGH = 262144;
    const unsigned long STATE_SECURE_MED = 65536;
    const unsigned long STATE_SECURE_LOW = 131072;

    void onStateChange(in nsIWebProgress web_progress,
                       in nsIRequest request,
                       in unsigned long state_flags,
                       in nsresult status);
                       
    void onProgressChange(in nsIWebProgress web_progress,
                          in nsIRequest request,
                          in long cur_self_progress,
                          in long max_self_progress,
                          in long cur_total_progress,
                          in long max_total_progress);
                      
    void onLocationChange(in nsIWebProgress web_progress,
                          in nsIRequest request,
                          in nsIURI location);
                          
    void onStatusChange(in nsIWebProgress web_progress,
                        in nsIRequest request,
                        in nsresult status,
                        in wstring message);
               
    void onSecurityChange(in nsIWebProgress web_progress,
                          in nsIRequest request,
                          in unsigned long state);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIWebProgressListener2
///////////////////////////////////////////////////////////////////////////////

[scriptable, uuid(dde39de0-e4e0-11da-8ad9-0800200c9a66)]
interface nsIWebProgressListener2 : nsIWebProgressListener
{
    void onProgressChange64(in nsIWebProgress web_progress,
                            in nsIRequest request,
                            in long long cur_self_progress,
                            in long long max_self_progress,
                            in long long cur_total_progress,
                            in long long max_total_progress);

    boolean onRefreshAttempted(
                            in nsIWebProgress web_progress,
                            in nsIURI refresh_uri,
                            in long millis,
                            in boolean same_uri);
};




/**
 * nsIMutable defines an interface to be implemented by objects which
 * can be made immutable.
 */
[scriptable, uuid(321578d0-03c1-4d95-8821-021ac612d18d)]
interface nsIMutable : nsISupports
{
    /**
     * Control whether or not this object can be modified.  If the flag is
     * false, no modification is allowed.  Once the flag has been set to false,
     * it cannot be reset back to true -- attempts to do so throw
     * NS_ERROR_INVALID_ARG.
     */
    attribute boolean mutable;
};

[scriptable, uuid(babd6cca-ebe7-4329-967c-d6b9e33caa81)]
interface nsIStandardURL : nsIMutable
{
    /**
     * blah:foo/bar    => blah://foo/bar
     * blah:/foo/bar   => blah:///foo/bar
     * blah://foo/bar  => blah://foo/bar
     * blah:///foo/bar => blah:///foo/bar
     */
    const unsigned long URLTYPE_STANDARD        = 1;

    /**
     * blah:foo/bar    => blah://foo/bar
     * blah:/foo/bar   => blah://foo/bar
     * blah://foo/bar  => blah://foo/bar
     * blah:///foo/bar => blah://foo/bar
     */
    const unsigned long URLTYPE_AUTHORITY       = 2;

    /**
     * blah:foo/bar    => blah:///foo/bar
     * blah:/foo/bar   => blah:///foo/bar
     * blah://foo/bar  => blah://foo/bar
     * blah:///foo/bar => blah:///foo/bar
     */
    const unsigned long URLTYPE_NO_AUTHORITY    = 3;

    /**
     * Initialize a standard URL.
     *
     * @param aUrlType       - one of the URLTYPE_ flags listed above.
     * @param aDefaultPort   - if the port parsed from the URL string matches
     *                         this port, then the port will be removed from the
     *                         canonical form of the URL.
     * @param aSpec          - URL string.
     * @param aOriginCharset - the charset from which this URI string
     *                         originated.  this corresponds to the charset
     *                         that should be used when communicating this
     *                         URI to an origin server, for example.  if
     *                         null, then provide aBaseURI implements this
     *                         interface, the origin charset of aBaseURI will
     *                         be assumed, otherwise defaulting to UTF-8 (i.e.,
     *                         no charset transformation from aSpec).
     * @param aBaseURI       - if null, aSpec must specify an absolute URI.
     *                         otherwise, aSpec will be resolved relative
     *                         to aBaseURI.
     */
    void init(in unsigned long aUrlType,
              in long aDefaultPort,
              in AUTF8String aSpec,
              in string aOriginCharset,
              in nsIURI aBaseURI);
};


///////////////////////////////////////////////////////////////////////////////
//  nsIURIContentListener
///////////////////////////////////////////////////////////////////////////////


interface nsIRequest;
interface nsIStreamListener;
interface nsIURIContentListener;

[scriptable, uuid(94928ab3-8b63-11d3-989d-001083010e9b)]
interface nsIURIContentListener : nsISupports
{
    boolean onStartURIOpen(in nsIURI uri);
    
    boolean doContent(in string content_type,
                      in boolean is_content_preferred,
                      in nsIRequest request,
                      out nsIStreamListener content_handler);
    
    boolean isPreferred(
                      in string content_type,
                      out string desired_content_type);
                      
    boolean canHandleContent(
                      in string content_type,
                      in boolean is_content_preferred,
                      out string desired_content_type);
               
    attribute nsISupports loadCookie;
    attribute nsIURIContentListener parentContentListener;
};




///////////////////////////////////////////////////////////////////////////////
//  nsIURILoader
///////////////////////////////////////////////////////////////////////////////


interface nsIURIContentListener;
interface nsIChannel;
interface nsIInterfaceRequestor;
interface nsIStreamListener;


[scriptable, uuid(2f7e8051-f1c9-4bcc-8584-9cfd5849e343)]
interface nsIURILoader : nsISupports
{
    const unsigned long IS_CONTENT_PREFERRED = 0x01;
    const unsigned long DONT_RETARGET = 0x02;

    void registerContentListener(in nsIURIContentListener content_listener);
    void unRegisterContentListener(in nsIURIContentListener content_listener);
    
    void openURI(in nsIChannel channel,
                 in boolean is_content_preferred,
                 in nsIInterfaceRequestor window_context);
    
    nsIStreamListener openChannel(in nsIChannel channel,
                                  in unsigned long flags,
                                  in nsIInterfaceRequestor window_context);

    void stop(in nsISupports load_cookie);
};





///////////////////////////////////////////////////////////////////////////////
//  nsIWebBrowserChrome
///////////////////////////////////////////////////////////////////////////////


interface nsIWebBrowser;

[scriptable, uuid(ba434c60-9d52-11d3-afb0-00a024ffc08c)]
interface nsIWebBrowserChrome : nsISupports
{
    void setStatus(in unsigned long status_type, in wstring status);
    attribute nsIWebBrowser webBrowser;
    
    const unsigned long STATUS_SCRIPT=0x00000001;
    const unsigned long STATUS_SCRIPT_DEFAULT=0x00000002;
    const unsigned long STATUS_LINK=0x00000003;

    const unsigned long CHROME_DEFAULT=0x00000001;
    const unsigned long CHROME_WINDOW_BORDERS=0x00000002;
    const unsigned long CHROME_WINDOW_CLOSE=0x00000004;
    const unsigned long CHROME_WINDOW_RESIZE=0x00000008;
    const unsigned long CHROME_MENUBAR=0x00000010;
    const unsigned long CHROME_TOOLBAR=0x00000020;
    const unsigned long CHROME_LOCATIONBAR=0x00000040;
    const unsigned long CHROME_STATUSBAR=0x00000080;
    const unsigned long CHROME_PERSONAL_TOOLBAR=0x00000100;
    const unsigned long CHROME_SCROLLBARS=0x00000200;
    const unsigned long CHROME_TITLEBAR=0x00000400;

    const unsigned long CHROME_WITH_SIZE=0x00001000;
    const unsigned long CHROME_WITH_POSITION=0x00002000;

    const unsigned long CHROME_WINDOW_MIN=0x00004000;
    const unsigned long CHROME_WINDOW_POPUP=0x00008000;
    const unsigned long CHROME_WINDOW_RAISED=0x02000000;
    const unsigned long CHROME_WINDOW_LOWERED=0x04000000;
    const unsigned long CHROME_CENTER_SCREEN=0x08000000;
    const unsigned long CHROME_DEPENDENT=0x10000000;
    const unsigned long CHROME_MODAL=0x20000000;
    const unsigned long CHROME_OPENAS_DIALOG=0x40000000;
    const unsigned long CHROME_OPENAS_CHROME =0x80000000;
    const unsigned long CHROME_ALL=0x00000ffe;
    
    attribute unsigned long chromeFlags;
    
    void destroyBrowserWindow();
    void sizeBrowserTo(in long cx, in long cy);
    void showAsModal();
    boolean isWindowModal();
    void exitModalEventLoop(in nsresult status);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIWebBrowserChromeFocus
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(d2206418-1dd1-11b2-8e55-acddcd2bcfb8)]
interface nsIWebBrowserChromeFocus : nsISupports
{
    void focusNextElement();
    void focusPrevElement();
};




///////////////////////////////////////////////////////////////////////////////
//  nsIWebBrowserFind
///////////////////////////////////////////////////////////////////////////////


[scriptable, object, uuid(2f977d44-5485-11d4-87e2-0010a4e75ef2)]
interface nsIWebBrowserFind : nsISupports
{
    boolean findNext();

    attribute wstring searchString;
    attribute boolean findBackwards;
    attribute boolean wrapFind;
    attribute boolean entireWord;
    attribute boolean matchCase;
    attribute boolean searchFrames;
};




///////////////////////////////////////////////////////////////////////////////
//  nsIWebBrowserFocus
///////////////////////////////////////////////////////////////////////////////


interface nsIDOMWindow;
interface nsIDOMElement;

[scriptable, uuid(9c5d3c58-1dd1-11b2-a1c9-f3699284657a)]
interface nsIWebBrowserFocus : nsISupports
{
    void activate();
    void deactivate();
    void setFocusAtFirstElement();
    void setFocusAtLastElement();
    
    attribute nsIDOMWindow focusedWindow;
    attribute nsIDOMElement focusedElement;
};




///////////////////////////////////////////////////////////////////////////////
//  nsIWebBrowserPersist
///////////////////////////////////////////////////////////////////////////////


interface nsIChannel;
interface nsIWebProgressListener;
interface nsIInputStream;
interface nsIDOMDocument;


[scriptable, uuid(dd4e0a6a-210f-419a-ad85-40e8543b9465)]
interface nsIWebBrowserPersist : nsICancelable
{
    const unsigned long PERSIST_FLAGS_NONE = 0;
    const unsigned long PERSIST_FLAGS_FROM_CACHE = 1;
    const unsigned long PERSIST_FLAGS_BYPASS_CACHE = 2;
    const unsigned long PERSIST_FLAGS_IGNORE_REDIRECTED_DATA = 4;
    const unsigned long PERSIST_FLAGS_IGNORE_IFRAMES = 8;
    const unsigned long PERSIST_FLAGS_NO_CONVERSION = 16;
    const unsigned long PERSIST_FLAGS_REPLACE_EXISTING_FILES = 32;
    const unsigned long PERSIST_FLAGS_NO_BASE_TAG_MODIFICATIONS = 64;
    const unsigned long PERSIST_FLAGS_FIXUP_ORIGINAL_DOM = 128;
    const unsigned long PERSIST_FLAGS_FIXUP_LINKS_TO_DESTINATION = 256;
    const unsigned long PERSIST_FLAGS_DONT_FIXUP_LINKS = 512;
    const unsigned long PERSIST_FLAGS_SERIALIZE_OUTPUT = 1024;
    const unsigned long PERSIST_FLAGS_DONT_CHANGE_FILENAMES = 2048;
    const unsigned long PERSIST_FLAGS_FAIL_ON_BROKEN_LINKS = 4096;
    const unsigned long PERSIST_FLAGS_CLEANUP_ON_FAILURE = 8192;
    const unsigned long PERSIST_FLAGS_AUTODETECT_APPLY_CONVERSION = 16384;
    
    const unsigned long PERSIST_STATE_READY = 1;
    const unsigned long PERSIST_STATE_SAVING = 2;
    const unsigned long PERSIST_STATE_FINISHED = 3;
    
    const unsigned long ENCODE_FLAGS_SELECTION_ONLY = 1;
    const unsigned long ENCODE_FLAGS_FORMATTED = 2;
    const unsigned long ENCODE_FLAGS_RAW = 4;
    const unsigned long ENCODE_FLAGS_BODY_ONLY = 8;
    const unsigned long ENCODE_FLAGS_PREFORMATTED = 16;
    const unsigned long ENCODE_FLAGS_WRAP = 32;
    const unsigned long ENCODE_FLAGS_FORMAT_FLOWED = 64;
    const unsigned long ENCODE_FLAGS_ABSOLUTE_LINKS = 128;
    const unsigned long ENCODE_FLAGS_ENCODE_W3C_ENTITIES = 256;
    const unsigned long ENCODE_FLAGS_CR_LINEBREAKS = 512;
    const unsigned long ENCODE_FLAGS_LF_LINEBREAKS = 1024;
    const unsigned long ENCODE_FLAGS_NOSCRIPT_CONTENT = 2048;
    const unsigned long ENCODE_FLAGS_NOFRAMES_CONTENT = 4096;
    const unsigned long ENCODE_FLAGS_ENCODE_BASIC_ENTITIES = 8192;
    const unsigned long ENCODE_FLAGS_ENCODE_LATIN1_ENTITIES = 16384;
    const unsigned long ENCODE_FLAGS_ENCODE_HTML_ENTITIES = 32768;

    attribute unsigned long persistFlags;
    readonly attribute unsigned long currentState;
    readonly attribute unsigned long result;
    attribute nsIWebProgressListener progressListener;
    
    void saveURI(in nsIURI uri,
                 in nsISupports cache_key,
                 in nsIURI referrer,
                 in nsIInputStream post_data,
                 in string extra_headers,
                 in nsIFile file);
                 
    void saveChannel(in nsIChannel channel,
                     in nsISupports file);
        
    void saveDocument(in nsIDOMDocument document,
                      in nsISupports file,
                      in nsISupports data_path,
                      in string output_content_type,
                      in unsigned long encoding_flags,
                      in unsigned long wrap_column);

    void cancelSave();
};




///////////////////////////////////////////////////////////////////////////////
//  nsIWebNavigation
///////////////////////////////////////////////////////////////////////////////


interface nsIInputStream;
interface nsIDOMDocument;
interface nsISHistory;

[scriptable, uuid(f5d9e7b0-d930-11d3-b057-00a024ffc08c)]
interface nsIWebNavigation : nsISupports
{
    readonly attribute boolean canGoBack;
    readonly attribute boolean canGoForward;
    
    void goBack();
    void goForward();
    void gotoIndex(in long index);
    
    const unsigned long LOAD_FLAGS_MASK = 65535;
    const unsigned long LOAD_FLAGS_NONE = 0;
    const unsigned long LOAD_FLAGS_IS_REFRESH = 16;
    const unsigned long LOAD_FLAGS_IS_LINK = 32;
    const unsigned long LOAD_FLAGS_BYPASS_HISTORY = 64;
    const unsigned long LOAD_FLAGS_REPLACE_HISTORY = 128;
    const unsigned long LOAD_FLAGS_BYPASS_CACHE = 256;
    const unsigned long LOAD_FLAGS_BYPASS_PROXY = 512;
    const unsigned long LOAD_FLAGS_CHARSET_CHANGE = 1024;
    const unsigned long LOAD_FLAGS_STOP_CONTENT = 2048;
    const unsigned long LOAD_FLAGS_FROM_EXTERNAL = 4096;
    const unsigned long STOP_NETWORK = 1;
    const unsigned long STOP_CONTENT = 2;
    const unsigned long STOP_ALL = 3;
    
    void loadURI(in wstring uri,
                 in unsigned long load_flags,
                 in nsIURI referrer,
                 in nsIInputStream post_data,
                 in nsIInputStream headers);

    void reload(in unsigned long reload_flags);
    void stop(in unsigned long stop_flags);
    
    readonly attribute nsIDOMDocument document;
    readonly attribute nsIURI currentURI;
    readonly attribute nsIURI referringURI;
    attribute nsISHistory sessionHistory;
};


///////////////////////////////////////////////////////////////////////////////
//  nsISHistory
///////////////////////////////////////////////////////////////////////////////

interface nsIHistoryEntry;
interface nsISHistoryListener;
interface nsISimpleEnumerator;
/**
 * An interface to the primary properties of the Session History
 * component. In an embedded browser environment, the nsIWebBrowser
 * object creates an instance of session history for each open window.
 * A handle to the session history object can be obtained from
 * nsIWebNavigation. In a non-embedded situation, the  owner of the
 * session history component must create a instance of it and set
 * it in the nsIWebNavigation object.
 * This interface is accessible from javascript. 
 *
 * @status FROZEN
 */
 

%{C++
#define NS_SHISTORY_CID \
{0x7294fe9c, 0x14d8, 0x11d5, {0x98, 0x82, 0x00, 0xC0, 0x4f, 0xa0, 0x2f, 0x40}}

#define NS_SHISTORY_CONTRACTID "@mozilla.org/browser/shistory;1"
%}

[scriptable, uuid(9883609F-CDD8-4d83-9B55-868FF08AD433)]
interface nsISHistory: nsISupports
{
  /**
   * A readonly property of the interface that returns 
   * the number of toplevel documents currently available
   * in session history.
   */
   readonly attribute long count;

  /**
   * A readonly property of the interface that returns 
   * the index of the current document in session history.
   */
   readonly attribute long index;

  /**
   * A readonly property of the interface that returns 
   * the index of the last document that started to load and
   * didn't finished yet. When document finishes the loading
   * value -1 is returned.
   */
   readonly attribute long requestedIndex;

  /**
   * A read/write property of the interface, used to Get/Set
   * the maximum number of toplevel documents, session history 
   * can hold for each instance. 
   */
   attribute long maxLength;

  /**
   * Called to obtain handle to the history entry at a
   * given index.
   *
   * @param index             The index value whose entry is requested.
   * @param modifyIndex       A boolean flag that indicates if the current
   *                          index of session history should be modified 
   *                          to the parameter index.
   *
   * @return                  <code>NS_OK</code> history entry for 
   *                          the index is obtained successfully.
   *                          <code>NS_ERROR_FAILURE</code> Error in obtaining
   *                          history entry for the given index.
   */
   nsIHistoryEntry getEntryAtIndex(in long index, in boolean modifyIndex);


  /**
   * Called to purge older documents from history.
   * Documents can be removed from session history for various 
   * reasons. For example to  control memory usage of the browser, to 
   * prevent users from loading documents from history, to erase evidence of
   * prior page loads etc...
   *
   * @param numEntries        The number of toplevel documents to be
   *                          purged from history. During purge operation,
   *                          the latest documents are maintained and older 
   *                          'numEntries' documents are removed from history.
   * @throws                  <code>NS_SUCCESS_LOSS_OF_INSIGNIFICANT_DATA</code> Purge was vetod.
   * @throws                  <code>NS_ERROR_FAILURE</code> numEntries is
   *                          invalid or out of bounds with the size of history.
   *                          
   */
   void PurgeHistory(in long numEntries);

  /**
   * Called to register a listener for the session history component.
   * Listeners are notified when pages are loaded or purged from history.
   * 
   * @param aListener         Listener object to be notified for all
   *                          page loads that initiate in session history.
   *
   * @note                    A listener object must implement 
   *                          nsISHistoryListener and nsSupportsWeakReference
   *
   * @see nsISHistoryListener
   * @see nsSupportsWeakReference
   */
   void addSHistoryListener(in nsISHistoryListener aListener);

  /**
   * Called to remove a listener for the session history component.
   * Listeners are notified when pages are loaded from history.
   * 
   * @param aListener         Listener object to be removed from 
   *                          session history.
   *
   * @note                    A listener object must implement 
   *                          nsISHistoryListener and nsSupportsWeakReference
   * @see nsISHistoryListener
   * @see nsSupportsWeakReference
   */ 
   void removeSHistoryListener(in nsISHistoryListener aListener);

  /**
   * Called to obtain a enumerator for all the  documents stored in 
   * session history. The enumerator object thus returned by this method
   * can be traversed using nsISimpleEnumerator. 
   *
   * @note  To access individual history entries of the enumerator, perform the
   *        following steps:
   *        1) Call nsISHistory->GetSHistoryEnumerator() to obtain handle 
   *           the nsISimpleEnumerator object.
   *        2) Use nsISimpleEnumerator->GetNext() on the object returned
   *           by step #1 to obtain handle to the next object in the list. 
   *           The object returned by this step is of type nsISupports.
   *        3) Perform a QueryInterface on the object returned by step #2 
   *           to nsIHistoryEntry.
   *        4) Use nsIHistoryEntry to access properties of each history entry. 
   *
   * @see nsISimpleEnumerator
   * @see nsIHistoryEntry
   * @see QueryInterface()
   * @see do_QueryInterface()
   */
   readonly attribute nsISimpleEnumerator SHistoryEnumerator;
};


///////////////////////////////////////////////////////////////////////////////
//  nsIWindowCreator
///////////////////////////////////////////////////////////////////////////////


interface nsIWebBrowserChrome;

[scriptable, uuid(30465632-a777-44cc-90f9-8145475ef999)]
interface nsIWindowCreator : nsISupports
{
    nsIWebBrowserChrome createChromeWindow(in nsIWebBrowserChrome parent,
                                           in unsigned long chrome_flags);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIWindowWatcher
///////////////////////////////////////////////////////////////////////////////


interface nsIDOMWindow;
interface nsIObserver;
interface nsISimpleEnumerator;
interface nsIAuthPrompt;
interface nsIWebBrowserChrome;
interface nsIPrompt;
interface nsIWindowCreator;

[scriptable, uuid(002286a8-494b-43b3-8ddd-49e3fc50622b)]
interface nsIWindowWatcher : nsISupports
{
    nsIDOMWindow openWindow(in nsIDOMWindow parent,
                            in string url,
                            in string name,
                            in string features,
                            in nsISupports arguments);
                            
    void registerNotification(in nsIObserver observer);
    void unregisterNotification(in nsIObserver observer);
    
    nsISimpleEnumerator getWindowEnumerator();
    nsIPrompt getNewPrompter(in nsIDOMWindow parent);
    nsIAuthPrompt getNewAuthPrompter(in nsIDOMWindow parent);
    void setWindowCreator(in nsIWindowCreator creator);
                            
    nsIWebBrowserChrome getChromeForWindow(in nsIDOMWindow window);
    
    nsIDOMWindow getWindowByName(in wstring target_name,
                                 in nsIDOMWindow current_window);
                                 
    attribute nsIDOMWindow activeWindow;
};




///////////////////////////////////////////////////////////////////////////////
//  nsIXPCSecurityManager
///////////////////////////////////////////////////////////////////////////////
[ptr] native nsAXPCNativeCallContextPtr(nsAXPCNativeCallContext);

%{ C++
#include "jspubtd.h"

class nsAXPCNativeCallContext;
%}

interface nsIClassInfo;

[scriptable, uuid(ea604e90-40ba-11d5-90bb-0010a4e73d9a)]
interface nsIProgrammingLanguage : nsISupports
{
    /**
     * Identifiers for programming languages.
     */
    const PRUint32 UNKNOWN     = 0;
    const PRUint32 CPLUSPLUS   = 1;
    const PRUint32 JAVASCRIPT  = 2;
    const PRUint32 PYTHON      = 3;
    const PRUint32 PERL        = 4;
    const PRUint32 JAVA        = 5;
    const PRUint32 ZX81_BASIC  = 6;  // it could happen :)
    const PRUint32 JAVASCRIPT2 = 7;
    const PRUint32 RUBY =        8;
    const PRUint32 PHP =         9;
    const PRUint32 TCL =         10;
    // This list can grow indefinitely. Just don't ever change an existing item.
    const PRUint32 MAX         = 10; // keep this as the largest index.
    
};

[ptr] native JSContextPtr(JSContext);
[ptr] native JSObjectPtr(JSObject);
      native JSVal(jsval);
[ptr] native JSStackFramePtr(JSStackFrame);

[uuid(31431440-f1ce-11d2-985a-006008962422)]
interface nsIXPCSecurityManager : nsISupports
{
    /**
    * These flags are used when calling nsIXPConnect::SetSecurityManager
    */

    const PRUint32 HOOK_CREATE_WRAPPER  = 1 << 0;
    const PRUint32 HOOK_CREATE_INSTANCE = 1 << 1;
    const PRUint32 HOOK_GET_SERVICE     = 1 << 2;
    const PRUint32 HOOK_CALL_METHOD     = 1 << 3;
    const PRUint32 HOOK_GET_PROPERTY    = 1 << 4;
    const PRUint32 HOOK_SET_PROPERTY    = 1 << 5;

    const PRUint32 HOOK_ALL             = HOOK_CREATE_WRAPPER  |
                                          HOOK_CREATE_INSTANCE |
                                          HOOK_GET_SERVICE     |
                                          HOOK_CALL_METHOD     |
                                          HOOK_GET_PROPERTY    |
                                          HOOK_SET_PROPERTY    ;

    /**
    * For each of these hooks returning NS_OK means 'let the action continue'.
    * Returning an error code means 'veto the action'. XPConnect will return
    * JS_FALSE to the js engine if the action is vetoed. The implementor of this
    * interface is responsible for setting a JS exception into the JSContext
    * if that is appropriate.
    */

    void CanCreateWrapper(in JSContextPtr aJSContext,
                          in nsIIDRef aIID,
                          in nsISupports aObj,
                          in nsIClassInfo aClassInfo,
                          inout voidPtr aPolicy);

    void CanCreateInstance(in JSContextPtr aJSContext,
                           in nsCIDRef aCID);

    void CanGetService(in JSContextPtr aJSContext,
                       in nsCIDRef aCID);

    /*
     * Used for aAction below
     */
    const PRUint32 ACCESS_CALL_METHOD  = 0;
    const PRUint32 ACCESS_GET_PROPERTY = 1;
    const PRUint32 ACCESS_SET_PROPERTY = 2;

    void CanAccess(in PRUint32 aAction,
                   in nsAXPCNativeCallContextPtr aCallContext,
                   in JSContextPtr aJSContext,
                   in JSObjectPtr aJSObject,
                   in nsISupports aObj,
                   in nsIClassInfo aClassInfo,
                   in JSVal aName,
                   inout voidPtr aPolicy);
};




/**
 * nsIProtocolHandler
 *
 * @status FROZEN
 */
[scriptable, uuid(15fd6940-8ea7-11d3-93ad-00104ba0fd40)]
interface nsIProtocolHandler : nsISupports
{
    /**
     * The scheme of this protocol (e.g., "file").
     */
    readonly attribute ACString scheme;

    /** 
     * The default port is the port that this protocol normally uses.
     * If a port does not make sense for the protocol (e.g., "about:")
     * then -1 will be returned.
     */
    readonly attribute long defaultPort;

    /**
     * Returns the protocol specific flags (see flag definitions below).  
     */
    readonly attribute unsigned long protocolFlags;

    /**
     * Makes a URI object that is suitable for loading by this protocol,
     * where the URI string is given as an UTF-8 string.  The caller may
     * provide the charset from which the URI string originated, so that
     * the URI string can be translated back to that charset (if necessary)
     * before communicating with, for example, the origin server of the URI
     * string.  (Many servers do not support UTF-8 IRIs at the present time,
     * so we must be careful about tracking the native charset of the origin
     * server.)
     *
     * @param aSpec          - the URI string in UTF-8 encoding. depending
     *                         on the protocol implementation, unicode character
     *                         sequences may or may not be %xx escaped.
     * @param aOriginCharset - the charset of the document from which this URI
     *                         string originated.  this corresponds to the
     *                         charset that should be used when communicating
     *                         this URI to an origin server, for example.  if
     *                         null, then UTF-8 encoding is assumed (i.e.,
     *                         no charset transformation from aSpec).
     * @param aBaseURI       - if null, aSpec must specify an absolute URI.
     *                         otherwise, aSpec may be resolved relative
     *                         to aBaseURI, depending on the protocol. 
     *                         If the protocol has no concept of relative 
     *                         URI aBaseURI will simply be ignored.
     */
    nsIURI newURI(in AUTF8String aSpec,
                  in string aOriginCharset,
                  in nsIURI aBaseURI);

    /**
     * Constructs a new channel from the given URI for this protocol handler. 
     */
    nsIChannel newChannel(in nsIURI aURI);

    /**
     * Allows a protocol to override blacklisted ports.
     *
     * This method will be called when there is an attempt to connect to a port 
     * that is blacklisted.  For example, for most protocols, port 25 (Simple Mail
     * Transfer) is banned.  When a URI containing this "known-to-do-bad-things" 
     * port number is encountered, this function will be called to ask if the 
     * protocol handler wants to override the ban.  
     */
    boolean allowPort(in long port, in string scheme);


    /**************************************************************************
     * Constants for the protocol flags (the first is the default mask, the
     * others are deviations):
     *
     * NOTE: Implementation must ignore any flags they do not understand.
     */

    /**
     * standard full URI with authority component and concept of relative
     * URIs (http, ftp, ...)
     */
    const unsigned long URI_STD = 0;

    /**
     * no concept of relative URIs (about, javascript, finger, ...)
     */
    const unsigned long URI_NORELATIVE = (1<<0);

    /**
     * no authority component (file, ...)
     */
    const unsigned long URI_NOAUTH = (1<<1);

    /**
     * The URIs for this protocol have no inherent security context, so
     * documents loaded via this protocol should inherit the security context
     * from the document that loads them.
     */
    const unsigned long URI_INHERITS_SECURITY_CONTEXT = (1<<4);

    /**
     * "Automatic" loads that would replace the document (e.g. <meta> refresh,
     * certain types of XLinks, possibly other loads that the application
     * decides are not user triggered) are not allowed if the originating (NOT
     * the target) URI has this protocol flag.  Note that the decision as to
     * what constitutes an "automatic" load is made externally, by the caller
     * of nsIScriptSecurityManager::CheckLoadURI.  See documentation for that
     * method for more information.
     *
     * A typical protocol that might want to set this flag is a protocol that
     * shows highly untrusted content in a viewing area that the user expects
     * to have a lot of control over, such as an e-mail reader.
     */
    const unsigned long URI_FORBIDS_AUTOMATIC_DOCUMENT_REPLACEMENT = (1<<5);

    /**
     * +-------------------------------------------------------------------+
     * |                                                                   |
     * |  ALL PROTOCOL HANDLERS MUST SET ONE OF THE FOLLOWING FOUR FLAGS.  |
     * |                                                                   |
     * +-------------------------------------------------------------------+
     *
     * These flags are used to determine who is allowed to load URIs for this
     * protocol.  Note that if a URI is nested, only the flags for the
     * innermost URI matter.  See nsINestedURI.
     *
     * If none of these four flags are set, the URI must be treated as if it
     * had the URI_LOADABLE_BY_ANYONE flag set, for compatibility with protocol
     * handlers written against Gecko 1.8 or earlier.  In this case, there may
     * be run-time warning messages indicating that a "default insecure"
     * assumption is being made.  At some point in the futures (Mozilla 2.0,
     * most likely), these warnings will become errors.
     */

    /**
     * The URIs for this protocol can be loaded by anyone.  For example, any
     * website should be allowed to trigger a load of a URI for this protocol.
     * Web-safe protocols like "http" should set this flag.
     */
    const unsigned long URI_LOADABLE_BY_ANYONE = (1<<6);
    
    /**
     * The URIs for this protocol are UNSAFE if loaded by untrusted (web)
     * content and may only be loaded by privileged code (for example, code
     * which has the system principal).  Various internal protocols should set
     * this flag.
     */
    const unsigned long URI_DANGEROUS_TO_LOAD = (1<<7);
    
    /**
     * The URIs for this protocol point to resources that are part of the
     * application's user interface.  There are cases when such resources may
     * be made accessible to untrusted content such as web pages, so this is
     * less restrictive than URI_DANGEROUS_TO_LOAD but more restrictive than
     * URI_LOADABLE_BY_ANYONE.  See the documentation for
     * nsIScriptSecurityManager::CheckLoadURI.
     */
    const unsigned long URI_IS_UI_RESOURCE = (1<<8);

    /**
     * Loading of URIs for this protocol from other origins should only be
     * allowed if those origins should have access to the local filesystem.
     * It's up to the application to decide what origins should have such
     * access.  Protocols like "file" that point to local data should set this
     * flag.
     */
    const unsigned long URI_IS_LOCAL_FILE = (1<<9);

    /**
     * Loading channels from this protocol has side-effects that make
     * it unsuitable for saving to a local file.
     */
    const unsigned long URI_NON_PERSISTABLE = (1<<10);

    /**
     * Channels using this protocol never call OnDataAvailable
     * on the listener passed to AsyncOpen and they therefore
     * do not return any data that we can use.
     */
    const unsigned long URI_DOES_NOT_RETURN_DATA = (1<<11);
    
    /**
     * This protocol handler can be proxied via a proxy (socks or http)
     * (e.g., irc, smtp, http, etc.).  If the protocol supports transparent
     * proxying, the handler should implement nsIProxiedProtocolHandler.
     *
     * If it supports only HTTP proxying, then it need not support
     * nsIProxiedProtocolHandler, but should instead set the ALLOWS_PROXY_HTTP
     * flag (see below).
     *
     * @see nsIProxiedProtocolHandler
     */
    const unsigned long ALLOWS_PROXY = (1<<2);

    /**
     * This protocol handler can be proxied using a http proxy (e.g., http,
     * ftp, etc.).  nsIIOService::newChannelFromURI will feed URIs from this
     * protocol handler to the HTTP protocol handler instead.  This flag is
     * ignored if ALLOWS_PROXY is not set.
     */
    const unsigned long ALLOWS_PROXY_HTTP = (1<<3);
};

%{C++
/**
 * Protocol handlers are registered with XPCOM under the following CONTRACTID prefix:
 */
#define NS_NETWORK_PROTOCOL_CONTRACTID_PREFIX "@mozilla.org/network/protocol;1?name="
/**
 * For example, "@mozilla.org/network/protocol;1?name=http"
 */
%}

[ptr] native nsNonConstIDPtr(nsID);

/**
 * nsIUUIDGenerator is implemented by a service that can generate
 * universally unique identifiers, ideally using any platform-native
 * method for generating UUIDs.
 */
[scriptable, uuid(138ad1b2-c694-41cc-b201-333ce936d8b8)]
interface nsIUUIDGenerator : nsISupports
{
  /**
   * Obtains a new UUID using appropriate platform-specific methods to
   * obtain a nsID that can be considered to be globally unique.
   *
   * @returns an nsID filled in with a new UUID.
   *
   * @throws NS_ERROR_FAILURE if a UUID cannot be generated (e.g. if
   * an underlying source of randomness is not available)
   */
  nsIDPtr generateUUID();

  /**
   * Obtain a new UUID like the generateUUID method, but place it in
   * the provided nsID pointer instead of allocating a new nsID.
   *
   * @param id an existing nsID pointer where the UUID will be stored.
   *
   * @throws NS_ERROR_FAILURE if a UUID cannot be generated (e.g. if
   * an underlying source of randomness is not available)
   */
  [noscript] void generateUUIDInPlace(in nsNonConstIDPtr id);
};

[scriptable, uuid(86d02f0e-219b-4cfc-9c88-bd98d2cce0b8)]
interface nsIWebBrowserStream : nsISupports
{
  /**
   * Prepare to load a stream of data. When this function returns successfully,
   * it must be paired by a call to closeStream.
   *
   * @param aBaseURI
   *        The base URI of the data. Must not be null. Relative
   *        URIs will be resolved relative to this URI.
   * @param aContentType
   *        ASCII string giving the content type of the data. If rendering
   *        content of this type is not supported, this method fails.
   *        This string may include a charset declaration, for example:
   *        text/html;charset=ISO-8859-1
   *
   * @throw NS_ERROR_NOT_AVAILABLE
   *        The requested content type is not supported.
   * @throw NS_ERROR_IN_PROGRESS
   *        openStream was called twice without an intermediate closeStream.
   */
  void openStream(in nsIURI aBaseURI, in ACString aContentType);

  /**
   * Append data to this stream.
   * @param aData The data to append
   * @param aLen  Length of the data to append.
   *
   * @note To append more than 4 GB of data, call this method multiple times.
   */
  void appendToStream([const, array, size_is(aLen)] in octet aData,
                      in unsigned long aLen);

  /**
   * Notifies the browser that all the data has been appended. This may notify
   * the user that the browser is "done loading" in some form.
   *
   * @throw NS_ERROR_UNEXPECTED
   *        This method was called without a preceding openStream.
   */
  void closeStream();
};


///////////////////////////////////////////////////////////////////////////////
//  nsISSLCertErrorDialog
///////////////////////////////////////////////////////////////////////////////

[scriptable, uuid(0729ce8e-8935-4989-ba72-a2d6307f2365)]
interface nsISSLCertErrorDialog : nsISupports
{
    void showCertError(in nsIInterfaceRequestor ctx, 
                       in nsISSLStatus status,
                       in nsIX509Cert cert,
                       in AString text_error_message,
                       in AString html_error_message,
                       in ACString host_name,
                       in PRUint32 port_number);
};
